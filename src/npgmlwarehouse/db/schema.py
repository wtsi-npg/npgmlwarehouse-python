# -*- coding: utf-8 -*-
#
# Copyright Â© 2025 Genome Research Ltd. All rights reserved.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import datetime
import decimal
from typing import Optional

from sqlalchemy import (
    DECIMAL,
    JSON,
    TIMESTAMP,
    BigInteger,
    Column,
    Computed,
    Date,
    DateTime,
    Enum,
    Float,
    ForeignKeyConstraint,
    Index,
    Integer,
    SmallInteger,
    String,
    Table,
    text,
)
from sqlalchemy.dialects.mysql import (
    BIGINT,
    CHAR,
    DATETIME,
    DOUBLE,
    ENUM,
    FLOAT,
    INTEGER,
    MEDIUMTEXT,
    SMALLINT,
    TEXT,
    TINYINT,
    VARCHAR,
)
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship

"""ORM for the multi-lims warehouse database schema.

These classes were generated by sqlacodegen to provide access to the tables
of the existing multi-lims warehouse database schema.

Listing of manual changes to the generated code:
  - CHAR has been removed from the import from sqlalchemy to avoid a clash
    with the import from sqlalchemy.dialects.mysql
  - Single quotes for 'CURRENT_TIMESTAMP' in t_iseq_heron_product_metrics_view
    have been removed due to 'Invalid default value' error during CREATE.
  - CHAR(32, "utf8mb3_unicode_ci") has been replaced by
    CHAR(32, collation="utf8mb3_unicode_ci") in the instrument_name column
    of useq_run_metrics (UseqRunMetrics) due to invalid arguments
  - CHAR(64, "utf8mb3_unicode_ci") has been replaced by
    CHAR(64, collation="utf8mb3_unicode_ci") in the id_useq_product column
    of useq_product_metrics (UseqProductMetrics) due to invalid arguments
"""


class Base(DeclarativeBase):
    pass


class Aliquot(Base):
    __tablename__ = "aliquot"

    id: Mapped[int] = mapped_column(BigInteger, primary_key=True)
    id_lims: Mapped[str] = mapped_column(
        VARCHAR(255),
        nullable=False,
        comment="The LIMS system that the aliquot was created in",
    )
    aliquot_uuid: Mapped[str] = mapped_column(
        VARCHAR(255),
        nullable=False,
        comment="The UUID of the aliquot in the LIMS system",
    )
    aliquot_type: Mapped[str] = mapped_column(
        VARCHAR(255), nullable=False, comment="The type of the aliquot"
    )
    source_type: Mapped[str] = mapped_column(
        VARCHAR(255), nullable=False, comment="The type of the source of the aliquot"
    )
    source_barcode: Mapped[str] = mapped_column(
        VARCHAR(255), nullable=False, comment="The barcode of the source of the aliquot"
    )
    sample_name: Mapped[str] = mapped_column(
        VARCHAR(255),
        nullable=False,
        comment="The name of the sample that the aliquot was created from",
    )
    used_by_type: Mapped[str] = mapped_column(
        VARCHAR(255),
        nullable=False,
        comment="The type of the entity that the aliquot is used by",
    )
    used_by_barcode: Mapped[str] = mapped_column(
        VARCHAR(255),
        nullable=False,
        comment="The barcode of the entity that the aliquot is used by",
    )
    volume: Mapped[decimal.Decimal] = mapped_column(
        DECIMAL(10, 2), nullable=False, comment="The volume of the aliquot (uL)"
    )
    last_updated: Mapped[datetime.datetime] = mapped_column(
        DATETIME(fsp=6),
        nullable=False,
        comment="The date and time that the aliquot was last updated",
    )
    recorded_at: Mapped[datetime.datetime] = mapped_column(
        DATETIME(fsp=6),
        nullable=False,
        comment="The date and time that the aliquot was recorded",
    )
    created_at: Mapped[datetime.datetime] = mapped_column(
        DATETIME(fsp=6),
        nullable=False,
        comment="The date and time that this record was created",
    )
    concentration: Mapped[Optional[decimal.Decimal]] = mapped_column(
        DECIMAL(10, 2), comment="The concentration of the aliquot (ng/ul)"
    )
    insert_size: Mapped[Optional[int]] = mapped_column(
        Integer, comment="The size of the insert in base pairs"
    )


class ArInternalMetadata(Base):
    __tablename__ = "ar_internal_metadata"

    key: Mapped[str] = mapped_column(String(255), primary_key=True)
    created_at: Mapped[datetime.datetime] = mapped_column(
        DATETIME(fsp=6), nullable=False
    )
    updated_at: Mapped[datetime.datetime] = mapped_column(
        DATETIME(fsp=6), nullable=False
    )
    value: Mapped[Optional[str]] = mapped_column(String(255))


class CgapAnalyte(Base):
    __tablename__ = "cgap_analyte"
    __table_args__ = (
        Index("cell_line_uuid", "cell_line_uuid"),
        Index("slot_uuid", "slot_uuid", unique=True),
    )

    cgap_analyte_tmp: Mapped[int] = mapped_column(
        INTEGER,
        primary_key=True,
        comment="Internal to this database id. Value can change.",
    )
    cell_line_uuid: Mapped[str] = mapped_column(VARCHAR(36), nullable=False)
    destination: Mapped[str] = mapped_column(VARCHAR(32), nullable=False)
    slot_uuid: Mapped[str] = mapped_column(VARCHAR(36), nullable=False)
    release_date: Mapped[datetime.datetime] = mapped_column(
        TIMESTAMP, nullable=False, server_default=text("'0000-00-00 00:00:00'")
    )
    labware_barcode: Mapped[str] = mapped_column(VARCHAR(20), nullable=False)
    cell_state: Mapped[str] = mapped_column(VARCHAR(40), nullable=False)
    jobs: Mapped[Optional[str]] = mapped_column(VARCHAR(64))
    passage_number: Mapped[Optional[int]] = mapped_column(Integer)
    project: Mapped[Optional[str]] = mapped_column(VARCHAR(50))


class CgapBiomaterial(Base):
    __tablename__ = "cgap_biomaterial"
    __table_args__ = (
        Index("biomaterial_uuid", "biomaterial_uuid", unique=True),
        Index("donor_uuid", "donor_uuid"),
    )

    cgap_biomaterial_tmp: Mapped[int] = mapped_column(
        INTEGER,
        primary_key=True,
        comment="Internal to this database id. Value can change.",
    )
    donor_uuid: Mapped[str] = mapped_column(VARCHAR(36), nullable=False)
    biomaterial_uuid: Mapped[str] = mapped_column(VARCHAR(36), nullable=False)
    donor_accession_number: Mapped[Optional[str]] = mapped_column(VARCHAR(38))
    donor_name: Mapped[Optional[str]] = mapped_column(VARCHAR(64))


class CgapConjuredLabware(Base):
    __tablename__ = "cgap_conjured_labware"
    __table_args__ = (
        Index("barcode", "barcode"),
        Index("cell_line_long_name", "cell_line_long_name"),
        Index("cell_line_uuid", "cell_line_uuid"),
        Index("conjure_date", "conjure_date"),
        Index("labware_state", "labware_state"),
        Index("project", "project"),
        Index("slot_uuid", "slot_uuid", unique=True),
    )

    cgap_conjured_labware_tmp: Mapped[int] = mapped_column(
        INTEGER,
        primary_key=True,
        comment="Internal to this database id. Value can change.",
    )
    barcode: Mapped[str] = mapped_column(VARCHAR(32), nullable=False)
    cell_line_long_name: Mapped[str] = mapped_column(VARCHAR(48), nullable=False)
    cell_line_uuid: Mapped[str] = mapped_column(VARCHAR(38), nullable=False)
    passage_number: Mapped[int] = mapped_column(Integer, nullable=False)
    conjure_date: Mapped[datetime.datetime] = mapped_column(
        TIMESTAMP, nullable=False, server_default=text("'0000-00-00 00:00:00'")
    )
    labware_state: Mapped[str] = mapped_column(VARCHAR(20), nullable=False)
    slot_uuid: Mapped[str] = mapped_column(VARCHAR(36), nullable=False)
    fate: Mapped[Optional[str]] = mapped_column(VARCHAR(40))
    project: Mapped[Optional[str]] = mapped_column(VARCHAR(50))


class CgapDestruction(Base):
    __tablename__ = "cgap_destruction"
    __table_args__ = (
        Index("barcode", "barcode"),
        Index("cell_line_long_name", "cell_line_long_name"),
        Index("destroyed", "destroyed"),
        Index("project", "project"),
    )

    cgap_destruction_tmp: Mapped[int] = mapped_column(
        INTEGER,
        primary_key=True,
        comment="Internal to this database. Value can change.",
    )
    barcode: Mapped[str] = mapped_column(VARCHAR(32), nullable=False)
    cell_line_long_name: Mapped[str] = mapped_column(VARCHAR(48), nullable=False)
    destroyed: Mapped[datetime.datetime] = mapped_column(
        TIMESTAMP, nullable=False, server_default=text("'0000-00-00 00:00:00'")
    )
    cell_state: Mapped[str] = mapped_column(VARCHAR(40), nullable=False)
    project: Mapped[Optional[str]] = mapped_column(VARCHAR(50))


class CgapHeron(Base):
    __tablename__ = "cgap_heron"
    __table_args__ = (
        Index("cgap_heron_destination_wrangled", "destination", "wrangled"),
        Index(
            "cgap_heron_rack_and_position", "container_barcode", "position", unique=True
        ),
        Index("cgap_heron_release_time", "release_time"),
        Index("cgap_heron_sample_identifier", "sample_identifier"),
        Index("cgap_heron_study", "study"),
        Index("cgap_heron_supplier_sample_id", "supplier_sample_id"),
        Index("tube_barcode", "tube_barcode", unique=True),
    )

    cgap_heron_tmp: Mapped[int] = mapped_column(
        INTEGER,
        primary_key=True,
        comment="Internal to this database id. Value can change.",
    )
    container_barcode: Mapped[str] = mapped_column(VARCHAR(32), nullable=False)
    supplier_sample_id: Mapped[str] = mapped_column(VARCHAR(64), nullable=False)
    position: Mapped[str] = mapped_column(VARCHAR(8), nullable=False)
    sample_type: Mapped[str] = mapped_column(VARCHAR(32), nullable=False)
    release_time: Mapped[datetime.datetime] = mapped_column(
        TIMESTAMP, nullable=False, server_default=text("'0000-00-00 00:00:00'")
    )
    study: Mapped[str] = mapped_column(VARCHAR(32), nullable=False)
    destination: Mapped[str] = mapped_column(VARCHAR(32), nullable=False)
    sample_state: Mapped[str] = mapped_column(VARCHAR(32), nullable=False)
    tube_barcode: Mapped[Optional[str]] = mapped_column(VARCHAR(32))
    wrangled: Mapped[Optional[datetime.datetime]] = mapped_column(TIMESTAMP)
    lysis_buffer: Mapped[Optional[str]] = mapped_column(VARCHAR(64))
    priority: Mapped[Optional[int]] = mapped_column(TINYINT)
    sample_identifier: Mapped[Optional[str]] = mapped_column(
        VARCHAR(64),
        comment="The COG-UK barcode of a sample or the mixtio barcode of a control",
    )
    control_type: Mapped[Optional[str]] = mapped_column(ENUM("Positive", "Negative"))
    control_accession_number: Mapped[Optional[str]] = mapped_column(VARCHAR(32))


class CgapLineIdentifier(Base):
    __tablename__ = "cgap_line_identifier"
    __table_args__ = (
        Index("biomaterial_uuid", "biomaterial_uuid"),
        Index("direct_parent_uuid", "direct_parent_uuid"),
        Index("friendly_name", "friendly_name"),
        Index("line_uuid", "line_uuid", unique=True),
    )

    cgap_line_identifier_tmp: Mapped[int] = mapped_column(
        INTEGER,
        primary_key=True,
        comment="Internal to this database id. Value can change.",
    )
    line_uuid: Mapped[str] = mapped_column(VARCHAR(36), nullable=False)
    friendly_name: Mapped[str] = mapped_column(VARCHAR(48), nullable=False)
    biomaterial_uuid: Mapped[str] = mapped_column(VARCHAR(36), nullable=False)
    accession_number: Mapped[Optional[str]] = mapped_column(VARCHAR(38))
    direct_parent_uuid: Mapped[Optional[str]] = mapped_column(VARCHAR(36))
    project: Mapped[Optional[str]] = mapped_column(VARCHAR(50))


class CgapOrganoidsConjuredLabware(Base):
    __tablename__ = "cgap_organoids_conjured_labware"
    __table_args__ = (
        Index("barcode", "barcode"),
        Index("cell_line_long_name", "cell_line_long_name"),
        Index("cell_line_uuid", "cell_line_uuid"),
        Index("conjure_date", "conjure_date"),
        Index("labware_state", "labware_state"),
    )

    cgap_organoids_conjured_labware_tmp: Mapped[int] = mapped_column(
        INTEGER,
        primary_key=True,
        comment="Internal to this database id. Value can change.",
    )
    barcode: Mapped[str] = mapped_column(VARCHAR(20), nullable=False)
    cell_line_long_name: Mapped[str] = mapped_column(VARCHAR(48), nullable=False)
    cell_line_uuid: Mapped[str] = mapped_column(VARCHAR(38), nullable=False)
    passage_number: Mapped[int] = mapped_column(Integer, nullable=False)
    conjure_date: Mapped[datetime.datetime] = mapped_column(
        TIMESTAMP, nullable=False, server_default=text("'0000-00-00 00:00:00'")
    )
    labware_state: Mapped[str] = mapped_column(VARCHAR(20), nullable=False)
    fate: Mapped[Optional[str]] = mapped_column(VARCHAR(40))


class CgapRelease(Base):
    __tablename__ = "cgap_release"
    __table_args__ = (
        Index("barcode", "barcode"),
        Index("cell_line_long_name", "cell_line_long_name"),
        Index("cell_line_uuid", "cell_line_uuid"),
        Index("project", "project"),
    )

    cgap_release_tmp: Mapped[int] = mapped_column(
        INTEGER,
        primary_key=True,
        comment="Internal to this database id. Value can change.",
    )
    barcode: Mapped[str] = mapped_column(VARCHAR(20), nullable=False)
    cell_line_long_name: Mapped[str] = mapped_column(VARCHAR(48), nullable=False)
    cell_line_uuid: Mapped[str] = mapped_column(VARCHAR(38), nullable=False)
    goal: Mapped[str] = mapped_column(VARCHAR(64), nullable=False)
    jobs: Mapped[str] = mapped_column(VARCHAR(64), nullable=False)
    user: Mapped[str] = mapped_column(VARCHAR(6), nullable=False)
    release_date: Mapped[datetime.datetime] = mapped_column(
        TIMESTAMP, nullable=False, server_default=text("'0000-00-00 00:00:00'")
    )
    cell_state: Mapped[str] = mapped_column(VARCHAR(40), nullable=False)
    passage_number: Mapped[int] = mapped_column(Integer, nullable=False)
    destination: Mapped[Optional[str]] = mapped_column(VARCHAR(64))
    fate: Mapped[Optional[str]] = mapped_column(VARCHAR(40))
    project: Mapped[Optional[str]] = mapped_column(VARCHAR(50))


class CgapSupplierBarcode(Base):
    __tablename__ = "cgap_supplier_barcode"
    __table_args__ = (
        Index("biomaterial_uuid", "biomaterial_uuid"),
        Index("supplier_barcode", "supplier_barcode", unique=True),
    )

    cgap_supplier_barcode_tmp: Mapped[int] = mapped_column(
        INTEGER,
        primary_key=True,
        comment="Internal to this database id. Value can change.",
    )
    biomaterial_uuid: Mapped[str] = mapped_column(VARCHAR(36), nullable=False)
    supplier_barcode: Mapped[str] = mapped_column(VARCHAR(20), nullable=False)
    date: Mapped[datetime.datetime] = mapped_column(
        TIMESTAMP, nullable=False, server_default=text("'0000-00-00 00:00:00'")
    )


t_cherrypicked_samples = Table(
    "cherrypicked_samples",
    Base.metadata,
    Column("root_sample_id", MEDIUMTEXT),
    Column("plate_barcode", String(255)),
    Column("phenotype", String(255)),
    Column("coordinate", String(255)),
    Column("created", DateTime),
    Column("robot_type", String(7)),
)


class Comments(Base):
    __tablename__ = "comments"

    id: Mapped[int] = mapped_column(BigInteger, primary_key=True)
    id_lims: Mapped[str] = mapped_column(
        VARCHAR(10), nullable=False, comment="ID of the LIMS"
    )
    comment_type: Mapped[str] = mapped_column(
        VARCHAR(255),
        nullable=False,
        comment="Type of the comment e.g., under_representation",
    )
    recorded_at: Mapped[datetime.datetime] = mapped_column(
        DATETIME(fsp=6),
        nullable=False,
        comment="Timestamp of the latest warehouse update.",
    )
    last_updated: Mapped[datetime.datetime] = mapped_column(
        DATETIME(fsp=6),
        nullable=False,
        comment="The date the comment was last updated in LIMS.",
    )
    comment_value: Mapped[Optional[str]] = mapped_column(
        TEXT, comment="Value of the comment corresponding to the comment_type"
    )
    batch_id: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="Corresponds to id_flowcell_lims in iseq_flowcell table."
    )
    position: Mapped[Optional[int]] = mapped_column(
        SMALLINT, comment="Position of the lane in the flowcell"
    )
    tag_index: Mapped[Optional[int]] = mapped_column(
        SMALLINT, comment="Index of the tag (check iseq_flowcell tag_index column)"
    )


class EseqRun(Base):
    __tablename__ = "eseq_run"
    __table_args__ = (
        Index("eseq_run_fname_unique", "folder_name", unique=True),
        {
            "comment": "Information about a run performed on an Element Biosciences "
            "instrument derived from instrument output"
        },
    )

    id_eseq_run_tmp: Mapped[int] = mapped_column(
        BIGINT,
        primary_key=True,
        comment="Internal to this database id, value can change",
    )
    folder_name: Mapped[str] = mapped_column(
        VARCHAR(200),
        nullable=False,
        comment="Run folder name created by the Element Biosciences instrument",
    )
    run_name: Mapped[str] = mapped_column(
        VARCHAR(100),
        nullable=False,
        comment="Run name as recorded in RunParameters.json file",
    )
    flowcell_id: Mapped[str] = mapped_column(
        VARCHAR(100),
        nullable=False,
        comment="Flowcell ID as recorded in RunParameters.json file",
    )
    run_parameters: Mapped[dict] = mapped_column(
        JSON,
        nullable=False,
        comment="The content of RunParameters.json file in the run folder",
    )
    run_type: Mapped[Optional[str]] = mapped_column(
        VARCHAR(100), comment="Run type as recorded in RunParameters.json file"
    )
    date_started: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime, comment="Run date as recorded in RunParameters.json file"
    )
    date_completed: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime,
        comment="Run completion date from a timestamp of RunUploaded.json file",
    )
    run_manifest: Mapped[Optional[dict]] = mapped_column(
        JSON, comment="The content of RunManifest.json file in the run folder"
    )
    run_stats: Mapped[Optional[dict]] = mapped_column(
        JSON,
        comment="The content of RunStats.json file produced by bases2fastq, reserved for possible future use.",
    )
    outcome: Mapped[Optional[str]] = mapped_column(
        VARCHAR(256), comment="Run outcome as recorded in RunUploaded.json file"
    )


class EseqRunLaneMetrics(Base):
    __tablename__ = "eseq_run_lane_metrics"
    __table_args__ = (
        Index("eseq_rf_name_index", "run_folder_name"),
        Index("eseq_rlm_run_archived_index", "run_archived"),
    )

    id_run: Mapped[int] = mapped_column(
        INTEGER, primary_key=True, comment="NPG run identifier"
    )
    lane: Mapped[int] = mapped_column(
        SMALLINT, primary_key=True, comment="Flowcell lane number"
    )
    run_folder_name: Mapped[str] = mapped_column(
        VARCHAR(255), nullable=False, comment="Instrument run folder name"
    )
    instrument_name: Mapped[str] = mapped_column(
        CHAR(32), nullable=False, comment="Instrument name in NPG tracking system"
    )
    instrument_external_name: Mapped[str] = mapped_column(
        VARCHAR(255),
        nullable=False,
        comment="Name assigned to the instrument by the manufacturer",
    )
    instrument_model: Mapped[str] = mapped_column(
        VARCHAR(255), nullable=False, comment="Instrument model"
    )
    cancelled: Mapped[int] = mapped_column(
        TINYINT,
        nullable=False,
        server_default=text("'0'"),
        comment="Boolean flag to indicate whether the run was failed in some way or its data has been discarded",
    )
    cycles: Mapped[int] = mapped_column(
        INTEGER, nullable=False, comment="Actual number of cycles excluding index reads"
    )
    last_changed: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime,
        server_default=text("CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP"),
        comment="Date this record was created or changed",
    )
    flowcell_barcode: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="Manufacturer flowcell barcode"
    )
    instrument_side: Mapped[Optional[str]] = mapped_column(
        CHAR(1), comment="Instrument side (A or B)"
    )
    paired_read: Mapped[Optional[int]] = mapped_column(
        TINYINT, server_default=text("'0'")
    )
    run_priority: Mapped[Optional[int]] = mapped_column(TINYINT)
    run_started: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime, comment="Timestamp of run started status"
    )
    run_complete: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime, comment="Timestamp of run complete status"
    )
    lane_released: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime,
        comment="The date the lane was released, ie QC-ed if applicable and fully archived",
    )
    run_archived: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime,
        comment="The date the run was released, ie QC-ed if applicable and fully archived",
    )
    qc_seq: Mapped[Optional[int]] = mapped_column(
        TINYINT(1),
        comment="Sequencing lane level QC outcome, a result of either manual or automatic assessment by core",
    )
    num_polonies: Mapped[Optional[int]] = mapped_column(
        BIGINT, comment="Number of polonies (reads) for this lane"
    )
    tags_decode_percent: Mapped[Optional[float]] = mapped_column(
        FLOAT,
        comment="An overall percent of polonies (reads) assigned to expected barcodes",
    )

    eseq_product_metrics: Mapped[list["EseqProductMetrics"]] = relationship(
        "EseqProductMetrics", back_populates="eseq_run_lane_metrics"
    )


class IseqExternalProductMetrics(Base):
    __tablename__ = "iseq_external_product_metrics"
    __table_args__ = (
        Index("iseq_ext_pr_file_path", "file_path", unique=True),
        Index("iseq_ext_pr_flowcell", "flowcell_id"),
        Index("iseq_ext_pr_fname", "file_name"),
        Index("iseq_ext_pr_id_product", "id_iseq_product"),
        Index("iseq_ext_pr_id_run", "id_run"),
        Index("iseq_ext_pr_instrument", "instrument_id"),
        Index("iseq_ext_pr_lib_id", "library_id"),
        Index("iseq_ext_pr_manifest_status", "manifest_upload_status"),
        Index("iseq_ext_pr_plate_bc", "plate_barcode"),
        Index("iseq_ext_pr_prstatus", "processing_status"),
        Index("iseq_ext_pr_qc", "qc_overall_assessment"),
        Index("iseq_ext_pr_sample_name", "supplier_sample_name"),
        {"comment": "Externally computed metrics for data sequenced at WSI"},
    )

    id_iseq_ext_pr_metrics_tmp: Mapped[int] = mapped_column(
        BIGINT,
        primary_key=True,
        comment="Internal to this database id, value can change",
    )
    file_name: Mapped[str] = mapped_column(
        String(300),
        nullable=False,
        comment="Comma-delimitered alphabetically sorted list of file names, which unambigiously define WSI sources of data",
    )
    file_path: Mapped[str] = mapped_column(
        String(760),
        nullable=False,
        comment="Comma-delimitered alphabetically sorted list of full external file paths for the files in file_names column as uploaded by WSI",
    )
    created: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime,
        server_default=text("CURRENT_TIMESTAMP"),
        comment="Datetime this record was created",
    )
    last_changed: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime,
        server_default=text("CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP"),
        comment="Datetime this record was created or changed",
    )
    supplier_sample_name: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="Sample name given by the supplier, as recorded by WSI"
    )
    plate_barcode: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="Stock plate barcode, as recorded by WSI"
    )
    library_id: Mapped[Optional[int]] = mapped_column(
        Integer, comment="WSI library identifier"
    )
    md5_staging: Mapped[Optional[str]] = mapped_column(
        CHAR(32), comment="WSI validation hex MD5, not set for multiple source files"
    )
    manifest_upload_status: Mapped[Optional[str]] = mapped_column(
        CHAR(15),
        comment='WSI manifest upload status, one of "IN PROGRESS", "DONE", "FAIL", not set for multiple source files',
    )
    manifest_upload_status_change_date: Mapped[Optional[datetime.datetime]] = (
        mapped_column(
            DateTime, comment="Date the status of manifest upload is changed by WSI"
        )
    )
    id_run: Mapped[Optional[int]] = mapped_column(
        INTEGER,
        comment="NPG run identifier, defined where the product corresponds to a single line",
    )
    id_iseq_product: Mapped[Optional[str]] = mapped_column(
        CHAR(64), comment="product id"
    )
    iseq_composition_tmp: Mapped[Optional[str]] = mapped_column(
        String(600),
        comment="JSON representation of the composition object, the column might be deleted in future",
    )
    id_archive_product: Mapped[Optional[str]] = mapped_column(
        CHAR(64), comment="Archive ID for data product"
    )
    destination: Mapped[Optional[str]] = mapped_column(
        String(15),
        server_default=text("'UKBMP'"),
        comment='Data destination, from 20200323 defaults to "UKBMP"',
    )
    processing_status: Mapped[Optional[str]] = mapped_column(
        CHAR(15),
        comment='Overall status of the product, one of "PASS", "HOLD", "INSUFFICIENT", "FAIL"',
    )
    qc_overall_assessment: Mapped[Optional[str]] = mapped_column(
        CHAR(4),
        comment='State of the product after phase 3 of processing, one of "PASS" or "FAIL"',
    )
    qc_status: Mapped[Optional[str]] = mapped_column(
        CHAR(15),
        comment='State of the product after phase 2 of processing, one of "PASS", "HOLD", "INSUFFICIENT", "FAIL"',
    )
    sequencing_start_date: Mapped[Optional[datetime.date]] = mapped_column(
        Date,
        comment="Sequencing start date obtained from the CRAM file header, not set for multiple source files",
    )
    upload_date: Mapped[Optional[datetime.date]] = mapped_column(
        Date, comment="Upload date, not set for multiple source files"
    )
    md5_validation_date: Mapped[Optional[datetime.date]] = mapped_column(
        Date, comment="Date of MD5 validation, not set for multiple source files"
    )
    processing_start_date: Mapped[Optional[datetime.date]] = mapped_column(
        Date, comment="Processing start date"
    )
    analysis_start_date: Mapped[Optional[datetime.date]] = mapped_column(Date)
    phase2_end_date: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime, comment="Date the phase 2 analysis finished for this product"
    )
    analysis_end_date: Mapped[Optional[datetime.date]] = mapped_column(Date)
    archival_date: Mapped[Optional[datetime.date]] = mapped_column(
        Date, comment="Date made available or pushed to archive service"
    )
    archive_confirmation_date: Mapped[Optional[datetime.date]] = mapped_column(
        Date,
        comment="Date of confirmation of integrity of data product by archive service",
    )
    md5: Mapped[Optional[str]] = mapped_column(
        CHAR(32),
        comment="External validation hex MD5, not set for multiple source files",
    )
    md5_validation: Mapped[Optional[str]] = mapped_column(
        CHAR(4),
        comment='Outcome of MD5 validation as "PASS" or "FAIL", not set for multiple source files',
    )
    format_validation: Mapped[Optional[str]] = mapped_column(
        CHAR(4),
        comment='Outcome of format validation as "PASS" or "FAIL", not set for multiple source files',
    )
    upload_status: Mapped[Optional[str]] = mapped_column(
        CHAR(4),
        comment='Upload status as "PASS" or "FAIL", "PASS" if both MD5 and format validation are "PASS", not set for multiple source files',
    )
    instrument_id: Mapped[Optional[str]] = mapped_column(
        String(256),
        comment="Comma separated sorted list of instrument IDs obtained from the CRAM file header(s)",
    )
    flowcell_id: Mapped[Optional[str]] = mapped_column(
        String(256),
        comment="Comma separated sorted list of flowcell IDs obtained from the CRAM file header(s)",
    )
    annotation: Mapped[Optional[str]] = mapped_column(
        String(15),
        comment="Annotation regarding data provenance, i.e. is sequence data from first pass, re-run, top-up, etc.",
    )
    min_read_length: Mapped[Optional[int]] = mapped_column(
        TINYINT, comment="Minimum read length observed in the data file"
    )
    target_autosome_coverage_threshold: Mapped[Optional[int]] = mapped_column(
        INTEGER,
        server_default=text("'15'"),
        comment="Target autosome coverage threshold, defaults to 15",
    )
    target_autosome_gt_coverage_threshold: Mapped[Optional[float]] = mapped_column(
        Float,
        comment="Coverage percent at >= target_autosome_coverage_threshold X as a fraction",
    )
    target_autosome_gt_coverage_threshold_assessment: Mapped[Optional[str]] = (
        mapped_column(
            CHAR(4),
            comment='"PASS" if target_autosome_percent_gt_coverage_threshold > 95%, "FAIL" otherwise',
        )
    )
    verify_bam_id_score: Mapped[Optional[float]] = mapped_column(
        FLOAT, comment="FREEMIX value of sample contamination levels as a fraction"
    )
    verify_bam_id_score_assessment: Mapped[Optional[str]] = mapped_column(
        CHAR(4), comment='"PASS" if verify_bam_id_score > 0.01, "FAIL" otherwise'
    )
    double_error_fraction: Mapped[Optional[float]] = mapped_column(
        FLOAT,
        comment="Fraction of marker pairs with two read pairs evidencing parity and non-parity, may only be calculated if 1% <= verify_bam_id_score < 5%",
    )
    contamination_assessment: Mapped[Optional[str]] = mapped_column(
        CHAR(4),
        comment='"PASS" or "FAIL" based on verify_bam_id_score_assessment and double_error_fraction < 0.2%',
    )
    yield_whole_genome: Mapped[Optional[float]] = mapped_column(
        FLOAT,
        comment="Sequence data quantity (Gb) excluding duplicate reads, adaptors, overlapping bases from reads on the same fragment, soft-clipped bases",
    )
    yield_: Mapped[Optional[float]] = mapped_column(
        "yield",
        FLOAT,
        comment="Sequence data quantity (Gb) excluding duplicate reads, adaptors, overlapping bases from reads on the same fragment, soft-clipped bases, non-N autosome only",
    )
    yield_q20: Mapped[Optional[int]] = mapped_column(
        BIGINT,
        comment="Yield in bases at or above Q20 filtered in the same way as the yield column values",
    )
    yield_q30: Mapped[Optional[int]] = mapped_column(
        BIGINT,
        comment="Yield in bases at or above Q30 filtered in the same way as the yield column values",
    )
    num_reads: Mapped[Optional[int]] = mapped_column(
        BIGINT,
        comment="Number of reads filtered in the same way as the yield column values",
    )
    gc_fraction_forward_read: Mapped[Optional[float]] = mapped_column(FLOAT)
    gc_fraction_reverse_read: Mapped[Optional[float]] = mapped_column(FLOAT)
    adapter_contamination: Mapped[Optional[str]] = mapped_column(
        String(255),
        comment='The maximum over adapters and cycles in reads/fragments as a fraction per file and RG. Values for first and second reads separated with ",", and values for individual files separated with "/". e.g. "0.1/0.1/0.1/0.1,0.1/0.1/0.1/0.1"',
    )
    adapter_contamination_assessment: Mapped[Optional[str]] = mapped_column(
        String(255),
        comment='"PASS", "WARN", "FAIL" per read and file. Multiple values are represented as forward slash-separated array of strings with a comma separating entries for paired-end 1 and 2 reads e.g. "PASS/PASS/WARN/PASS,PASS/PASS/WARN/PASS"',
    )
    pre_adapter_min_total_qscore: Mapped[Optional[int]] = mapped_column(
        TINYINT,
        comment="Minimum of TOTAL_QSCORE values in PreAdapter report from CollectSequencingArtifactMetrics",
    )
    ref_bias_min_total_qscore: Mapped[Optional[int]] = mapped_column(
        TINYINT,
        comment="Minimum of TOTAL_QSCORE values in BaitBias report from CollectSequencingArtifactMetrics",
    )
    target_proper_pair_mapped_reads_fraction: Mapped[Optional[float]] = mapped_column(
        FLOAT,
        comment="Fraction of properly paired mapped reads filtered in the same way as the yield column values",
    )
    target_proper_pair_mapped_reads_assessment: Mapped[Optional[str]] = mapped_column(
        CHAR(4),
        comment='"PASS" if target_proper_pair_mapped_reads_fraction > 0.95, "FAIL" otherwise',
    )
    insert_size_mean: Mapped[Optional[float]] = mapped_column(FLOAT)
    insert_size_std: Mapped[Optional[float]] = mapped_column(FLOAT)
    sequence_error_rate: Mapped[Optional[float]] = mapped_column(
        FLOAT, comment="Reported by samtools, as a fraction"
    )
    basic_statistics_assessement: Mapped[Optional[str]] = mapped_column(
        String(255),
        comment='FastQC "PASS", "WARN", "FAIL" per input file. Array of strings separated by "/", with a "," separating entries for paired-end 1 and 2 reads. e.g. Four RG "PASS/PASS/WARN/PASS,PASS/PASS/WARN/PASS"',
    )
    overrepresented_sequences_assessement: Mapped[Optional[str]] = mapped_column(
        String(255),
        comment='FastQC "PASS", "WARN", "FAIL" per input file. Array of strings separated by "/", with a "," separating entries for paired-end 1 and 2 reads. e.g. Four RG "PASS/PASS/WARN/PASS,PASS/PASS/WARN/PASS"',
    )
    n_content_per_base_assessement: Mapped[Optional[str]] = mapped_column(
        String(255),
        comment='FastQC "PASS", "WARN", "FAIL" per input file. Array of strings separated by "/", with a "," separating entries for paired-end 1 and 2 reads. e.g. Four RG "PASS/PASS/WARN/PASS,PASS/PASS/WARN/PASS"',
    )
    sequence_content_per_base_assessement: Mapped[Optional[str]] = mapped_column(
        String(255),
        comment='FastQC "PASS", "WARN", "FAIL" per input file. Array of strings separated by "/", with a "," separating entries for paired-end 1 and 2 reads. e.g. Four RG "PASS/PASS/WARN/PASS,PASS/PASS/WARN/PASS"',
    )
    sequence_quality_per_base_assessement: Mapped[Optional[str]] = mapped_column(
        String(255),
        comment='FastQC "PASS", "WARN", "FAIL" per input file. Array of strings separated by "/", with a "," separating entries for paired-end 1 and 2 reads. e.g. Four RG "PASS/PASS/WARN/PASS,PASS/PASS/WARN/PASS"',
    )
    gc_content_per_sequence_assessement: Mapped[Optional[str]] = mapped_column(
        String(255),
        comment='FastQC "PASS", "WARN", "FAIL" per input file. Array of strings separated by "/", with a "," separating entries for paired-end 1 and 2 reads. e.g. Four RG "PASS/PASS/WARN/PASS,PASS/PASS/WARN/PASS"',
    )
    quality_scores_per_sequence_assessement: Mapped[Optional[str]] = mapped_column(
        String(255),
        comment='FastQC "PASS", "WARN", "FAIL" per input file. Array of strings separated by "/", with a "," separating entries for paired-end 1 and 2 reads. e.g. Four RG "PASS/PASS/WARN/PASS,PASS/PASS/WARN/PASS"',
    )
    sequence_duplication_levels_assessement: Mapped[Optional[str]] = mapped_column(
        String(255),
        comment='FastQC "PASS", "WARN", "FAIL" per input file. Array of strings separated by "/", with a "," separating entries for paired-end 1 and 2 reads. e.g. Four RG "PASS/PASS/WARN/PASS,PASS/PASS/WARN/PASS"',
    )
    sequence_length_distribution_assessement: Mapped[Optional[str]] = mapped_column(
        String(255),
        comment='FastQC "PASS", "WARN", "FAIL" per input file. Array of strings separated by "/", with a "," separating entries for paired-end 1 and 2 reads. e.g. Four RG "PASS/PASS/WARN/PASS,PASS/PASS/WARN/PASS"',
    )
    FastQC_overall_assessment: Mapped[Optional[str]] = mapped_column(
        CHAR(4), comment='FastQC "PASS" or "FAIL"'
    )
    nrd: Mapped[Optional[float]] = mapped_column(
        FLOAT,
        comment="Sample discordance levels at non-reference genotypes as a fraction",
    )
    nrd_assessment: Mapped[Optional[str]] = mapped_column(
        CHAR(4),
        comment='"PASS" based on nrd_persent < 2% or "FAIL" or "NA" if genotyping data not available for this sample',
    )
    sex_reported: Mapped[Optional[str]] = mapped_column(
        CHAR(6), comment="Sex as reported by sample supplier"
    )
    sex_computed: Mapped[Optional[str]] = mapped_column(
        CHAR(6), comment="Genetic sex as identified by sequence data"
    )
    input_files_status: Mapped[Optional[str]] = mapped_column(
        CHAR(10), comment="Status of the input files, either 'USEABLE' or 'DELETED'"
    )
    intermediate_files_status: Mapped[Optional[str]] = mapped_column(
        CHAR(10),
        comment="Status of the intermediate files, either 'USEABLE' or 'DELETED'",
    )
    output_files_status: Mapped[Optional[str]] = mapped_column(
        CHAR(10),
        comment="Status of the output files, either 'ARCHIVED', 'USEABLE' or 'DELETED'",
    )
    input_status_override_ref: Mapped[Optional[str]] = mapped_column(
        String(255), comment="Status override reference for the input files"
    )
    intermediate_status_override_ref: Mapped[Optional[str]] = mapped_column(
        String(255), comment="Status override reference for the intermediate files"
    )
    output_status_override_ref: Mapped[Optional[str]] = mapped_column(
        String(255), comment="Status override reference for the output files"
    )

    iseq_external_product_components: Mapped[list["IseqExternalProductComponents"]] = (
        relationship(
            "IseqExternalProductComponents",
            back_populates="iseq_external_product_metrics",
        )
    )


class IseqHeronClimbStatus(Base):
    __tablename__ = "iseq_heron_climb_status"
    __table_args__ = (
        Index("anonymous_sample_id_idx", "anonymous_sample_id"),
        Index("id_iseq_product_idx", "id_iseq_product"),
        Index("ihcs_climb_upload_idx", "climb_upload"),
        Index("ihcs_folder_name_idx", "folder_name"),
        Index("ihcs_supplier_sample_name", "supplier_sample_name"),
    )

    id: Mapped[int] = mapped_column(INTEGER, primary_key=True)
    id_iseq_product: Mapped[Optional[str]] = mapped_column(CHAR(64))
    supplier_sample_name: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    climb_upload: Mapped[Optional[datetime.datetime]] = mapped_column(DateTime)
    folder_name: Mapped[Optional[str]] = mapped_column(VARCHAR(64))
    climb_biosample_metadata_upload: Mapped[Optional[datetime.datetime]] = (
        mapped_column(DateTime)
    )
    cog_sample_meta: Mapped[Optional[int]] = mapped_column(TINYINT(1))
    climb_sequence_metadata_upload: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime
    )
    anonymous_sample_id: Mapped[Optional[str]] = mapped_column(VARCHAR(15))


class IseqHeronProductMetrics(Base):
    __tablename__ = "iseq_heron_product_metrics"
    __table_args__ = (
        Index("iseq_hrm_digest_unq", "id_iseq_product", unique=True),
        Index("iseq_hrm_idrun", "id_run"),
        Index("iseq_hrm_ppver", "pp_version"),
        Index("iseq_hrm_ssn", "supplier_sample_name"),
        {"comment": "Heron project additional metrics"},
    )

    id_iseq_hrpr_metrics_tmp: Mapped[int] = mapped_column(
        BIGINT,
        primary_key=True,
        comment="Internal to this database id, value can change",
    )
    id_iseq_product: Mapped[str] = mapped_column(
        CHAR(64),
        nullable=False,
        comment="Product id, a foreign key into iseq_product_metrics table",
    )
    created: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime,
        server_default=text("CURRENT_TIMESTAMP"),
        comment="Datetime this record was created",
    )
    last_changed: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime,
        server_default=text("CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP"),
        comment="Datetime this record was created or changed",
    )
    id_run: Mapped[Optional[int]] = mapped_column(INTEGER, comment="Run id")
    supplier_sample_name: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="Sample name given by the supplier, as recorded by WSI"
    )
    pp_name: Mapped[Optional[str]] = mapped_column(
        VARCHAR(40),
        server_default=text("'ncov2019-artic-nf'"),
        comment="The name of the pipeline that produced the QC metric",
    )
    pp_version: Mapped[Optional[str]] = mapped_column(
        VARCHAR(40),
        comment="The version of the pipeline specified in the pp_name column",
    )
    pp_repo_url: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="URL of the VCS repository for this pipeline"
    )
    artic_qc_outcome: Mapped[Optional[str]] = mapped_column(
        CHAR(15), comment='Artic pipeline QC outcome, "TRUE", "FALSE" or a NULL value'
    )
    climb_upload: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime, comment="Datetime files for this sample were uploaded to CLIMB"
    )
    cog_sample_meta: Mapped[Optional[int]] = mapped_column(
        TINYINT, comment="A Boolean flag to mark sample metadata upload to COG"
    )
    path_root: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="The uploaded files path root for the entity"
    )
    ivar_md: Mapped[Optional[int]] = mapped_column(
        SMALLINT, comment="ivar minimum depth used in generating the default consensus"
    )
    pct_N_bases: Mapped[Optional[float]] = mapped_column(
        Float, comment="Percent of N bases"
    )
    pct_covered_bases: Mapped[Optional[float]] = mapped_column(
        Float, comment="Percent of covered bases"
    )
    longest_no_N_run: Mapped[Optional[int]] = mapped_column(
        SMALLINT, comment="Longest consensus data stretch without N"
    )
    ivar_amd: Mapped[Optional[int]] = mapped_column(
        SMALLINT,
        comment="ivar minimum depth used in generating the additional consensus",
    )
    pct_N_bases_amd: Mapped[Optional[float]] = mapped_column(
        Float, comment="Percent of N bases in the additional consensus"
    )
    longest_no_N_run_amd: Mapped[Optional[int]] = mapped_column(
        SMALLINT, comment="Longest data stretch without N in the additional consensus"
    )
    num_aligned_reads: Mapped[Optional[int]] = mapped_column(
        BIGINT, comment="Number of aligned filtered reads"
    )


t_iseq_heron_product_metrics_view = Table(
    "iseq_heron_product_metrics_view",
    Base.metadata,
    Column("id_iseq_hrpr_metrics_tmp", BIGINT, server_default=text("'0'")),
    Column("created", DateTime, server_default=text("CURRENT_TIMESTAMP")),
    Column("last_changed", DateTime, server_default=text("CURRENT_TIMESTAMP")),
    Column("id_run", INTEGER),
    Column("id_iseq_product", CHAR(64)),
    Column("supplier_sample_name", String(255)),
    Column("pp_name", String(40), server_default=text("'ncov2019-artic-nf'")),
    Column("pp_version", String(40)),
    Column("pp_repo_url", String(255)),
    Column("artic_qc_outcome", CHAR(15)),
    Column("climb_upload", DateTime),
    Column("cog_sample_meta", TINYINT(1)),
    Column("path_root", String(255)),
    Column("ivar_md", SMALLINT),
    Column("pct_N_bases", Float),
    Column("pct_covered_bases", Float),
    Column("longest_no_N_run", SMALLINT),
    Column("ivar_amd", SMALLINT),
    Column("pct_N_bases_amd", Float),
    Column("longest_no_N_run_amd", SMALLINT),
    Column("num_aligned_reads", BIGINT),
)


class IseqRun(Base):
    __tablename__ = "iseq_run"
    __table_args__ = (
        Index("iseq_run_id_flowcell_lims", "id_flowcell_lims"),
        {
            "comment": "Table linking run and flowcell identities with the run folder "
            "name"
        },
    )

    id_run: Mapped[int] = mapped_column(
        INTEGER, primary_key=True, comment="NPG run identifier"
    )
    id_flowcell_lims: Mapped[Optional[str]] = mapped_column(
        VARCHAR(20), comment="LIMS specific flowcell id"
    )
    folder_name: Mapped[Optional[str]] = mapped_column(
        VARCHAR(64), comment="Runfolder name"
    )
    rp__read1_number_of_cycles: Mapped[Optional[int]] = mapped_column(
        SMALLINT, comment="Read 1 number of cycles"
    )
    rp__read2_number_of_cycles: Mapped[Optional[int]] = mapped_column(
        SMALLINT, comment="Read 2 number of cycles"
    )
    rp__flow_cell_mode: Mapped[Optional[str]] = mapped_column(
        VARCHAR(4), comment="Flowcell mode"
    )
    rp__workflow_type: Mapped[Optional[str]] = mapped_column(
        VARCHAR(16), comment="Workflow type"
    )
    rp__flow_cell_consumable_version: Mapped[Optional[str]] = mapped_column(
        VARCHAR(4), comment="Flowcell consumable version"
    )
    rp__sbs_consumable_version: Mapped[Optional[str]] = mapped_column(
        VARCHAR(4), comment="Sbs consumable version"
    )


class IseqRunLaneMetrics(Base):
    __tablename__ = "iseq_run_lane_metrics"
    __table_args__ = (
        Index("iseq_rlm_cancelled_and_run_complete_index", "cancelled", "run_complete"),
        Index("iseq_rlm_cancelled_and_run_pending_index", "cancelled", "run_pending"),
        Index("iseq_rlmm_id_run_index", "id_run"),
    )

    id_run: Mapped[int] = mapped_column(
        INTEGER, primary_key=True, comment="NPG run identifier"
    )
    position: Mapped[int] = mapped_column(
        SMALLINT, primary_key=True, comment="Flowcell lane number"
    )
    paired_read: Mapped[int] = mapped_column(
        TINYINT, nullable=False, server_default=text("'0'")
    )
    cycles: Mapped[int] = mapped_column(INTEGER, nullable=False)
    cancelled: Mapped[int] = mapped_column(
        TINYINT,
        nullable=False,
        server_default=text("'0'"),
        comment="Boolen flag to indicate whether the run was cancelled",
    )
    flowcell_barcode: Mapped[Optional[str]] = mapped_column(
        VARCHAR(15),
        comment="Manufacturer flowcell barcode or other identifier as recorded by NPG",
    )
    last_changed: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime,
        server_default=text("CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP"),
        comment="Date this record was created or changed",
    )
    qc_seq: Mapped[Optional[int]] = mapped_column(
        TINYINT(1),
        comment="Sequencing lane level QC outcome, a result of either manual or automatic assessment by core",
    )
    instrument_name: Mapped[Optional[str]] = mapped_column(CHAR(32))
    instrument_external_name: Mapped[Optional[str]] = mapped_column(
        CHAR(10), comment="Name assigned to the instrument by the manufacturer"
    )
    instrument_model: Mapped[Optional[str]] = mapped_column(CHAR(64))
    instrument_side: Mapped[Optional[str]] = mapped_column(
        CHAR(1), comment="Illumina instrument side (A or B), if appropriate"
    )
    workflow_type: Mapped[Optional[str]] = mapped_column(
        VARCHAR(20), comment="Illumina instrument workflow type"
    )
    run_pending: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime, comment="Timestamp of run pending status"
    )
    run_complete: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime, comment="Timestamp of run complete status"
    )
    lane_released: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime, comment="The date the lane was released, ie QC-ed and fully archived"
    )
    qc_complete: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime, comment="Timestamp of qc complete status"
    )
    pf_cluster_count: Mapped[Optional[int]] = mapped_column(BIGINT)
    raw_cluster_count: Mapped[Optional[int]] = mapped_column(BIGINT)
    raw_cluster_density: Mapped[Optional[decimal.Decimal]] = mapped_column(
        DOUBLE(12, 3)
    )
    pf_cluster_density: Mapped[Optional[decimal.Decimal]] = mapped_column(DOUBLE(12, 3))
    pf_bases: Mapped[Optional[int]] = mapped_column(BIGINT)
    q20_yield_kb_forward_read: Mapped[Optional[int]] = mapped_column(INTEGER)
    q20_yield_kb_reverse_read: Mapped[Optional[int]] = mapped_column(INTEGER)
    q30_yield_kb_forward_read: Mapped[Optional[int]] = mapped_column(INTEGER)
    q30_yield_kb_reverse_read: Mapped[Optional[int]] = mapped_column(INTEGER)
    q40_yield_kb_forward_read: Mapped[Optional[int]] = mapped_column(INTEGER)
    q40_yield_kb_reverse_read: Mapped[Optional[int]] = mapped_column(INTEGER)
    tags_decode_percent: Mapped[Optional[float]] = mapped_column(FLOAT(5, 2))
    tags_decode_cv: Mapped[Optional[float]] = mapped_column(FLOAT(6, 2))
    unexpected_tags_percent: Mapped[Optional[float]] = mapped_column(
        FLOAT(5, 2),
        comment="tag0_perfect_match_reads as a percentage of total_lane_reads",
    )
    tag_hops_percent: Mapped[Optional[float]] = mapped_column(
        FLOAT, comment="Percentage tag hops for dual index runs"
    )
    tag_hops_power: Mapped[Optional[float]] = mapped_column(
        FLOAT, comment="Power to detect tag hops for dual index runs"
    )
    run_priority: Mapped[Optional[int]] = mapped_column(
        TINYINT,
        comment="Sequencing lane level run priority, a result of either manual or default value set by core",
    )
    interop_cluster_count_total: Mapped[Optional[int]] = mapped_column(
        BIGINT,
        comment="Total cluster count for this lane (derived from Illumina InterOp files)",
    )
    interop_cluster_count_mean: Mapped[Optional[decimal.Decimal]] = mapped_column(
        DOUBLE,
        comment="Total cluster count, mean value over tiles of this lane (derived from Illumina InterOp files)",
    )
    interop_cluster_count_stdev: Mapped[Optional[decimal.Decimal]] = mapped_column(
        DOUBLE, comment="Standard deviation value for interop_cluster_count_mean"
    )
    interop_cluster_count_pf_total: Mapped[Optional[int]] = mapped_column(
        BIGINT,
        comment="Purity-filtered cluster count for this lane (derived from Illumina InterOp files)",
    )
    interop_cluster_count_pf_mean: Mapped[Optional[decimal.Decimal]] = mapped_column(
        DOUBLE,
        comment="Purity-filtered cluster count, mean value over tiles of this lane (derived from Illumina InterOp files)",
    )
    interop_cluster_count_pf_stdev: Mapped[Optional[decimal.Decimal]] = mapped_column(
        DOUBLE, comment="Standard deviation value for interop_cluster_count_pf_mean"
    )
    interop_cluster_density_mean: Mapped[Optional[decimal.Decimal]] = mapped_column(
        DOUBLE,
        comment="Cluster density, mean value over tiles of this lane (derived from Illumina InterOp files)",
    )
    interop_cluster_density_stdev: Mapped[Optional[decimal.Decimal]] = mapped_column(
        DOUBLE, comment="Standard deviation value for interop_cluster_density_mean"
    )
    interop_cluster_density_pf_mean: Mapped[Optional[decimal.Decimal]] = mapped_column(
        DOUBLE,
        comment="Purity-filtered cluster density, mean value over tiles of this lane (derived from Illumina InterOp files)",
    )
    interop_cluster_density_pf_stdev: Mapped[Optional[decimal.Decimal]] = mapped_column(
        DOUBLE, comment="Standard deviation value for interop_cluster_density_pf_mean"
    )
    interop_cluster_pf_mean: Mapped[Optional[float]] = mapped_column(
        FLOAT(5, 2),
        comment=" Percent of purity-filtered clusters, mean value over tiles of this lane (derived from Illumina InterOp files)",
    )
    interop_cluster_pf_stdev: Mapped[Optional[float]] = mapped_column(
        FLOAT(5, 2), comment="Standard deviation value for interop_cluster_pf_mean"
    )
    interop_occupied_mean: Mapped[Optional[float]] = mapped_column(
        FLOAT(5, 2),
        comment="Percent of occupied flowcell wells, a mean value over tiles of this lane (derived from Illumina InterOp files)",
    )
    interop_occupied_stdev: Mapped[Optional[float]] = mapped_column(
        FLOAT(5, 2), comment="Standard deviation value for interop_occupied_mean"
    )

    iseq_product_metrics: Mapped[list["IseqProductMetrics"]] = relationship(
        "IseqProductMetrics", back_populates="iseq_run_lane_metrics"
    )


class IseqRunStatusDict(Base):
    __tablename__ = "iseq_run_status_dict"
    __table_args__ = (Index("iseq_run_status_dict_description_index", "description"),)

    id_run_status_dict: Mapped[int] = mapped_column(INTEGER, primary_key=True)
    description: Mapped[str] = mapped_column(VARCHAR(64), nullable=False)
    iscurrent: Mapped[int] = mapped_column(TINYINT, nullable=False)
    temporal_index: Mapped[Optional[int]] = mapped_column(SMALLINT)

    iseq_run_status: Mapped[list["IseqRunStatus"]] = relationship(
        "IseqRunStatus", back_populates="iseq_run_status_dict"
    )


class LabwareLocation(Base):
    __tablename__ = "labware_location"
    __table_args__ = (
        Index(
            "index_labware_location_on_labware_barcode", "labware_barcode", unique=True
        ),
        Index("index_labware_location_on_location_barcode", "location_barcode"),
    )

    id: Mapped[int] = mapped_column(BigInteger, primary_key=True)
    labware_barcode: Mapped[str] = mapped_column(
        VARCHAR(255), nullable=False, comment="Barcode on the stored labware"
    )
    location_barcode: Mapped[str] = mapped_column(
        VARCHAR(255), nullable=False, comment="Barcode associated with storage location"
    )
    full_location_address: Mapped[str] = mapped_column(
        VARCHAR(255),
        nullable=False,
        comment="Fully qualifed address of the nested location",
    )
    location_name: Mapped[str] = mapped_column(
        VARCHAR(255),
        nullable=False,
        server_default=text("''"),
        comment="Name of location where labware is stored",
    )
    lims_id: Mapped[str] = mapped_column(
        VARCHAR(255),
        nullable=False,
        comment="ID of the storage system this data comes from",
    )
    stored_by: Mapped[str] = mapped_column(
        VARCHAR(255),
        nullable=False,
        comment="Username of the person who placed the item there",
    )
    stored_at: Mapped[datetime.datetime] = mapped_column(
        DATETIME(fsp=6),
        nullable=False,
        comment="Datetime the item was stored at this location",
    )
    created_at: Mapped[datetime.datetime] = mapped_column(
        DATETIME(fsp=6), nullable=False
    )
    updated_at: Mapped[datetime.datetime] = mapped_column(
        DATETIME(fsp=6), nullable=False
    )
    coordinate_position: Mapped[Optional[int]] = mapped_column(
        Integer, comment="Coordinate position of labware in storage location"
    )
    coordinate_row: Mapped[Optional[int]] = mapped_column(
        Integer, comment="Coordinate row of labware in storage location"
    )
    coordinate_column: Mapped[Optional[int]] = mapped_column(
        Integer, comment="Coordinate column of labware in storage location"
    )


t_labware_location_old = Table(
    "labware_location_old",
    Base.metadata,
    Column("id", BigInteger, nullable=False, server_default=text("'0'")),
    Column(
        "labware_barcode",
        VARCHAR(255),
        nullable=False,
        comment="Barcode on the stored labware",
    ),
    Column(
        "location_barcode",
        VARCHAR(255),
        nullable=False,
        comment="Barcode associated with storage location",
    ),
    Column(
        "full_location_address",
        VARCHAR(255),
        nullable=False,
        comment="Fully qualifed address of the nested location",
    ),
    Column(
        "coordinate_position",
        Integer,
        comment="Coordinate position of labware in storage location",
    ),
    Column(
        "coordinate_row",
        Integer,
        comment="Coordinate row of labware in storage location",
    ),
    Column(
        "coordinate_column",
        Integer,
        comment="Coordinate column of labware in storage location",
    ),
    Column(
        "lims_id",
        VARCHAR(255),
        nullable=False,
        comment="ID of the storage system this data comes from",
    ),
    Column(
        "stored_by",
        VARCHAR(255),
        nullable=False,
        comment="Username of the person who placed the item there",
    ),
    Column(
        "stored_at",
        DATETIME(fsp=6),
        nullable=False,
        comment="Datetime the item was stored at this location",
    ),
    Column("created_at", DATETIME(fsp=6), nullable=False),
    Column("updated_at", DATETIME(fsp=6), nullable=False),
)


class LighthouseSample(Base):
    __tablename__ = "lighthouse_sample"
    __table_args__ = (
        Index("index_lighthouse_sample_on_cog_uk_id", "cog_uk_id"),
        Index(
            "index_lighthouse_sample_on_cog_uk_id_and_cog_uk_id_unique",
            "cog_uk_id",
            "cog_uk_id_unique",
            unique=True,
        ),
        Index(
            "index_lighthouse_sample_on_current_rna_id", "current_rna_id", unique=True
        ),
        Index("index_lighthouse_sample_on_date_tested", "date_tested"),
        Index("index_lighthouse_sample_on_filtered_positive", "filtered_positive"),
        Index(
            "index_lighthouse_sample_on_lh_sample_uuid", "lh_sample_uuid", unique=True
        ),
        Index("index_lighthouse_sample_on_mongodb_id", "mongodb_id", unique=True),
        Index(
            "index_lighthouse_sample_on_plate_barcode_and_created_at",
            "plate_barcode",
            "created_at",
        ),
        Index("index_lighthouse_sample_on_result", "result"),
        Index("index_lighthouse_sample_on_rna_id", "rna_id"),
        Index(
            "index_lighthouse_sample_on_root_sample_id_and_rna_id_and_result",
            "root_sample_id",
            "rna_id",
            "result",
            unique=True,
        ),
    )

    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    root_sample_id: Mapped[str] = mapped_column(
        VARCHAR(255),
        nullable=False,
        comment="Id for this sample provided by the Lighthouse lab",
    )
    cog_uk_id: Mapped[str] = mapped_column(VARCHAR(255), nullable=False)
    rna_id: Mapped[str] = mapped_column(
        VARCHAR(255),
        nullable=False,
        comment="Lighthouse lab-provided id made up of plate barcode and well",
    )
    result: Mapped[str] = mapped_column(
        VARCHAR(255),
        nullable=False,
        comment="Covid-19 test result from the Lighthouse lab",
    )
    is_current: Mapped[int] = mapped_column(
        TINYINT(1),
        nullable=False,
        server_default=text("'0'"),
        comment="Identifies if this sample has the most up to date information for the same rna_id",
    )
    mongodb_id: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="Auto-generated id from MongoDB"
    )
    cog_uk_id_unique: Mapped[Optional[int]] = mapped_column(
        TINYINT(1),
        server_default=text("'1'"),
        comment="A flag to indicate cog_uk_id should be unique. NULL allows reuse of the ID in another row.",
    )
    plate_barcode: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="Barcode of plate sample arrived in, from rna_id"
    )
    coordinate: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="Well position from plate sample arrived in, from rna_id"
    )
    date_tested_string: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255),
        comment="When the covid-19 test was carried out by the Lighthouse lab",
    )
    date_tested: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime, comment="date_tested_string in date format"
    )
    source: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="Lighthouse centre that the sample came from"
    )
    lab_id: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="Id of the lab, within the Lighthouse centre"
    )
    ch1_target: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    ch1_result: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    ch1_cq: Mapped[Optional[decimal.Decimal]] = mapped_column(DECIMAL(11, 8))
    ch2_target: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    ch2_result: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    ch2_cq: Mapped[Optional[decimal.Decimal]] = mapped_column(DECIMAL(11, 8))
    ch3_target: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    ch3_result: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    ch3_cq: Mapped[Optional[decimal.Decimal]] = mapped_column(DECIMAL(11, 8))
    ch4_target: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    ch4_result: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    ch4_cq: Mapped[Optional[decimal.Decimal]] = mapped_column(DECIMAL(11, 8))
    filtered_positive: Mapped[Optional[int]] = mapped_column(
        TINYINT(1), comment="Filtered positive result value"
    )
    filtered_positive_version: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="Filtered positive version"
    )
    filtered_positive_timestamp: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime, comment="Filtered positive timestamp"
    )
    lh_sample_uuid: Mapped[Optional[str]] = mapped_column(
        VARCHAR(36), comment="Sample uuid created in crawler"
    )
    lh_source_plate_uuid: Mapped[Optional[str]] = mapped_column(
        VARCHAR(36), comment="Source plate uuid created in crawler"
    )
    created_at: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime, comment="When this record was inserted"
    )
    updated_at: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime, comment="When this record was last updated"
    )
    must_sequence: Mapped[Optional[int]] = mapped_column(
        TINYINT(1), comment="PAM provided value whether sample is of high importance"
    )
    preferentially_sequence: Mapped[Optional[int]] = mapped_column(
        TINYINT(1), comment="PAM provided value whether sample is important"
    )
    current_rna_id: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), Computed("(if((`is_current` = 1),`rna_id`,NULL))", persisted=True)
    )


class LongReadQcResult(Base):
    __tablename__ = "long_read_qc_result"
    __table_args__ = (
        Index("index_long_read_qc_result_on_assay_type_key", "assay_type_key"),
        Index("index_long_read_qc_result_on_sample_id", "sample_id"),
    )

    id_long_read_qc_result_tmp: Mapped[int] = mapped_column(
        BigInteger, primary_key=True
    )
    labware_barcode: Mapped[str] = mapped_column(
        VARCHAR(255),
        nullable=False,
        comment="Barcode of the labware that was the source for the QC tests.",
    )
    sample_id: Mapped[str] = mapped_column(
        VARCHAR(255), nullable=False, comment="External identifier for the sample(s)."
    )
    assay_type: Mapped[str] = mapped_column(
        VARCHAR(255), nullable=False, comment="Type of the QC test."
    )
    assay_type_key: Mapped[str] = mapped_column(
        VARCHAR(255), nullable=False, comment="Unique identifier of the QC test."
    )
    value: Mapped[str] = mapped_column(
        VARCHAR(255), nullable=False, comment="QC result value"
    )
    units: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="Unit of the value for example mg,ng etc"
    )
    id_lims: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="Identifier of the LIMS where QC was published from"
    )
    id_long_read_qc_result_lims: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="LIMS specific id for QC result"
    )
    created: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime, comment="The date the qc_result was first created in LIMS"
    )
    last_updated: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime, comment="The date the qc_result was last updated in LIMS."
    )
    recorded_at: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime, comment="Timestamp of the latest warehouse update."
    )
    qc_status: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="Status of the QC decision eg pass, fail etc"
    )
    qc_status_decision_by: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="Who made the QC status decision eg ToL, Long Read"
    )


class PacBioRunWellMetrics(Base):
    __tablename__ = "pac_bio_run_well_metrics"
    __table_args__ = (
        Index(
            "pac_bio_metrics_run_well",
            "pac_bio_run_name",
            "well_label",
            "plate_number",
            unique=True,
        ),
        Index("pac_bio_rw_metrics_id_product", "id_pac_bio_product", unique=True),
        Index("pb_rw_qc_date_index", "qc_seq_date"),
        Index("pb_rw_qc_state_index", "qc_seq_state", "qc_seq_state_is_final"),
        Index("pbrw_ccs_execmode_index", "ccs_execution_mode"),
        Index("pbrw_movie_name_index", "movie_name"),
        Index("pbrw_run_complete_index", "run_complete"),
        Index("pbrw_well_complete_index", "well_complete"),
        {
            "comment": "Status and run information by well and some basic QC data from "
            "SMRT Link"
        },
    )

    id_pac_bio_rw_metrics_tmp: Mapped[int] = mapped_column(Integer, primary_key=True)
    id_pac_bio_product: Mapped[str] = mapped_column(
        CHAR(64), nullable=False, comment="Product id"
    )
    pac_bio_run_name: Mapped[str] = mapped_column(
        VARCHAR(255),
        nullable=False,
        comment="Lims specific identifier for the pacbio run",
    )
    well_label: Mapped[str] = mapped_column(
        VARCHAR(255),
        nullable=False,
        comment="The well identifier for the plate, A1-H12",
    )
    instrument_type: Mapped[str] = mapped_column(
        VARCHAR(32), nullable=False, comment="The instrument type e.g. Sequel"
    )
    plate_number: Mapped[Optional[int]] = mapped_column(
        Integer,
        comment="The number of the plate that goes onto the Revio sequencing machine. Necessary as an identifier for multi-plate support.",
    )
    qc_seq_state: Mapped[Optional[str]] = mapped_column(
        String(255), comment="Current sequencing QC state"
    )
    qc_seq_state_is_final: Mapped[Optional[int]] = mapped_column(
        TINYINT(1),
        comment="A flag marking the sequencing QC state as final (1) or not final (0)",
    )
    qc_seq_date: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime, comment="The date the current sequencing QC state was assigned"
    )
    qc_seq: Mapped[Optional[int]] = mapped_column(
        TINYINT(1),
        comment="The final sequencing QC outcome as 0(failed), 1(passed) or NULL",
    )
    instrument_name: Mapped[Optional[str]] = mapped_column(
        VARCHAR(32), comment="The instrument name e.g. SQ54097"
    )
    chip_type: Mapped[Optional[str]] = mapped_column(
        VARCHAR(32), comment="The chip type e.g. 8mChip"
    )
    sl_hostname: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="SMRT Link server hostname"
    )
    sl_run_uuid: Mapped[Optional[str]] = mapped_column(
        VARCHAR(36), comment="SMRT Link specific run uuid"
    )
    sl_ccs_uuid: Mapped[Optional[str]] = mapped_column(
        VARCHAR(36), comment="SMRT Link specific ccs dataset uuid"
    )
    ts_run_name: Mapped[Optional[str]] = mapped_column(
        VARCHAR(32), comment="The PacBio run name"
    )
    movie_name: Mapped[Optional[str]] = mapped_column(
        VARCHAR(32), comment="The PacBio movie name"
    )
    movie_minutes: Mapped[Optional[int]] = mapped_column(
        SMALLINT, comment="Movie time (collection time) in minutes"
    )
    created_by: Mapped[Optional[str]] = mapped_column(
        VARCHAR(32), comment="Created by user name recorded in SMRT Link"
    )
    binding_kit: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="Binding kit version"
    )
    sequencing_kit: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="Sequencing kit version"
    )
    sequencing_kit_lot_number: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="Sequencing Kit lot number"
    )
    cell_lot_number: Mapped[Optional[str]] = mapped_column(
        String(32), comment="SMRT Cell Lot Number"
    )
    ccs_execution_mode: Mapped[Optional[str]] = mapped_column(
        VARCHAR(32),
        comment="The PacBio ccs exection mode e.g. OnInstument, OffInstument or None",
    )
    demultiplex_mode: Mapped[Optional[str]] = mapped_column(
        VARCHAR(32),
        comment="Demultiplexing mode e.g. OnInstument, OffInstument or None",
    )
    include_kinetics: Mapped[Optional[int]] = mapped_column(
        TINYINT, comment="Include kinetics information where ccs is run"
    )
    hifi_only_reads: Mapped[Optional[int]] = mapped_column(
        TINYINT,
        comment="CCS was run on the instrument and only HiFi reads were included in the export from the instrument",
    )
    heteroduplex_analysis: Mapped[Optional[int]] = mapped_column(
        TINYINT,
        comment="Analysis has been run on the instrument to detect and resolve heteroduplex reads",
    )
    loading_conc: Mapped[Optional[float]] = mapped_column(
        FLOAT, comment="SMRT Cell loading concentration (pM)"
    )
    run_start: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime, comment="Timestamp of run started"
    )
    run_complete: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime, comment="Timestamp of run complete"
    )
    run_transfer_complete: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime, comment="Timestamp of run transfer complete"
    )
    run_status: Mapped[Optional[str]] = mapped_column(
        String(32),
        comment="Last recorded status, primarily to explain runs not completed.",
    )
    well_start: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime, comment="Timestamp of well started"
    )
    well_complete: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime, comment="Timestamp of well complete"
    )
    well_status: Mapped[Optional[str]] = mapped_column(
        String(32),
        comment="Last recorded status, primarily to explain wells not completed.",
    )
    chemistry_sw_version: Mapped[Optional[str]] = mapped_column(
        VARCHAR(32), comment="The PacBio chemistry software version"
    )
    instrument_sw_version: Mapped[Optional[str]] = mapped_column(
        VARCHAR(32), comment="The PacBio instrument software version"
    )
    primary_analysis_sw_version: Mapped[Optional[str]] = mapped_column(
        VARCHAR(32), comment="The PacBio primary analysis software version"
    )
    control_num_reads: Mapped[Optional[int]] = mapped_column(
        INTEGER, comment="The number of control reads"
    )
    control_concordance_mean: Mapped[Optional[float]] = mapped_column(
        FLOAT(8, 6),
        comment="The average concordance between the control raw reads and the control reference sequence",
    )
    control_concordance_mode: Mapped[Optional[float]] = mapped_column(
        FLOAT,
        comment="The modal value from the concordance between the control raw reads and the control reference sequence",
    )
    control_read_length_mean: Mapped[Optional[int]] = mapped_column(
        INTEGER, comment="The mean polymerase read length of the control reads"
    )
    local_base_rate: Mapped[Optional[float]] = mapped_column(
        FLOAT(8, 6),
        comment="The average base incorporation rate, excluding polymerase pausing events",
    )
    polymerase_read_bases: Mapped[Optional[int]] = mapped_column(
        BIGINT,
        comment="Calculated by multiplying the number of productive (P1) ZMWs by the mean polymerase read length",
    )
    polymerase_num_reads: Mapped[Optional[int]] = mapped_column(
        INTEGER, comment="The number of polymerase reads"
    )
    polymerase_read_length_mean: Mapped[Optional[int]] = mapped_column(
        INTEGER, comment="The mean high-quality read length of all polymerase reads"
    )
    polymerase_read_length_n50: Mapped[Optional[int]] = mapped_column(
        INTEGER,
        comment="Fifty percent of the trimmed read length of all polymerase reads are longer than this value",
    )
    insert_length_mean: Mapped[Optional[int]] = mapped_column(
        INTEGER,
        comment="The average subread length, considering only the longest subread from each ZMW",
    )
    insert_length_n50: Mapped[Optional[int]] = mapped_column(
        INTEGER,
        comment="Fifty percent of the subreads are longer than this value when considering only the longest subread from each ZMW",
    )
    unique_molecular_bases: Mapped[Optional[int]] = mapped_column(
        BIGINT, comment="The unique molecular yield in bp"
    )
    productive_zmws_num: Mapped[Optional[int]] = mapped_column(
        INTEGER, comment="Number of productive ZMWs"
    )
    p0_num: Mapped[Optional[int]] = mapped_column(
        INTEGER, comment="Number of empty ZMWs with no high quality read detected"
    )
    p1_num: Mapped[Optional[int]] = mapped_column(
        INTEGER, comment="Number of ZMWs with a high quality read detected"
    )
    p2_num: Mapped[Optional[int]] = mapped_column(
        INTEGER,
        comment="Number of other ZMWs, signal detected but no high quality read",
    )
    adapter_dimer_percent: Mapped[Optional[float]] = mapped_column(
        FLOAT(5, 2),
        comment="The percentage of pre-filter ZMWs which have observed inserts of 0-10 bp",
    )
    short_insert_percent: Mapped[Optional[float]] = mapped_column(
        FLOAT(5, 2),
        comment="The percentage of pre-filter ZMWs which have observed inserts of 11-100 bp",
    )
    hifi_read_bases: Mapped[Optional[int]] = mapped_column(
        BIGINT, comment="The number of HiFi bases"
    )
    hifi_num_reads: Mapped[Optional[int]] = mapped_column(
        INTEGER, comment="The number of HiFi reads"
    )
    hifi_read_length_mean: Mapped[Optional[int]] = mapped_column(
        INTEGER, comment="The mean HiFi read length"
    )
    hifi_read_quality_median: Mapped[Optional[int]] = mapped_column(
        SMALLINT, comment="The median HiFi base quality"
    )
    hifi_number_passes_mean: Mapped[Optional[int]] = mapped_column(
        INTEGER, comment="The mean number of passes per HiFi read"
    )
    hifi_low_quality_read_bases: Mapped[Optional[int]] = mapped_column(
        BIGINT, comment="The number of HiFi bases filtered due to low quality (<Q20)"
    )
    hifi_low_quality_num_reads: Mapped[Optional[int]] = mapped_column(
        INTEGER, comment="The number of HiFi reads filtered due to low quality (<Q20)"
    )
    hifi_low_quality_read_length_mean: Mapped[Optional[int]] = mapped_column(
        INTEGER,
        comment="The mean length of HiFi reads filtered due to low quality (<Q20)",
    )
    hifi_low_quality_read_quality_median: Mapped[Optional[int]] = mapped_column(
        SMALLINT,
        comment="The median base quality of HiFi bases filtered due to low quality (<Q20)",
    )
    hifi_barcoded_reads: Mapped[Optional[int]] = mapped_column(
        INTEGER,
        comment="Number of reads with an expected barcode in demultiplexed HiFi data",
    )
    hifi_bases_in_barcoded_reads: Mapped[Optional[int]] = mapped_column(
        BIGINT,
        comment="Number of bases in reads with an expected barcode in demultiplexed HiFi data",
    )
    last_changed: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime,
        server_default=text("CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP"),
        comment="Date this record was created or changed",
    )

    pac_bio_product_metrics: Mapped[list["PacBioProductMetrics"]] = relationship(
        "PacBioProductMetrics", back_populates="pac_bio_run_well_metrics"
    )


class PsdSampleCompoundsComponents(Base):
    __tablename__ = "psd_sample_compounds_components"
    __table_args__ = {
        "comment": "A join table owned by PSD to associate compound samples with "
        "their component samples."
    }

    id: Mapped[int] = mapped_column(BigInteger, primary_key=True)
    compound_id_sample_tmp: Mapped[int] = mapped_column(
        Integer,
        nullable=False,
        comment="The warehouse ID of the compound sample in the association.",
    )
    component_id_sample_tmp: Mapped[int] = mapped_column(
        Integer,
        nullable=False,
        comment="The warehouse ID of the component sample in the association.",
    )
    last_updated: Mapped[datetime.datetime] = mapped_column(
        DateTime, nullable=False, comment="Timestamp of last update."
    )
    recorded_at: Mapped[datetime.datetime] = mapped_column(
        DateTime, nullable=False, comment="Timestamp of warehouse update."
    )


class Sample(Base):
    __tablename__ = "sample"
    __table_args__ = (
        Index("index_sample_on_id_lims", "id_lims"),
        Index(
            "index_sample_on_id_lims_and_id_sample_lims",
            "id_lims",
            "id_sample_lims",
            unique=True,
        ),
        Index("index_sample_on_id_sample_lims", "id_sample_lims"),
        Index(
            "index_sample_on_id_sample_lims_and_id_lims",
            "id_sample_lims",
            "id_lims",
            unique=True,
        ),
        Index("index_sample_on_sanger_sample_id", "sanger_sample_id"),
        Index("index_sample_on_supplier_name", "supplier_name"),
        Index("sample_accession_number_index", "accession_number"),
        Index("sample_name_index", "name"),
        Index("sample_uuid_sample_lims_index", "uuid_sample_lims", unique=True),
    )

    id_sample_tmp: Mapped[int] = mapped_column(
        INTEGER,
        primary_key=True,
        comment="Internal to this database id, value can change",
    )
    id_lims: Mapped[str] = mapped_column(
        VARCHAR(10),
        nullable=False,
        comment="LIM system identifier, e.g. CLARITY-GCLP, SEQSCAPE",
    )
    uuid_sample_lims: Mapped[str] = mapped_column(
        VARCHAR(36), nullable=False, comment="LIMS-specific sample uuid"
    )
    id_sample_lims: Mapped[str] = mapped_column(
        VARCHAR(255), nullable=False, comment="LIMS-specific sample identifier"
    )
    last_updated: Mapped[datetime.datetime] = mapped_column(
        DateTime, nullable=False, comment="Timestamp of last update"
    )
    recorded_at: Mapped[datetime.datetime] = mapped_column(
        DateTime, nullable=False, comment="Timestamp of warehouse update"
    )
    consent_withdrawn: Mapped[int] = mapped_column(
        TINYINT(1), nullable=False, server_default=text("'0'")
    )
    deleted_at: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime, comment="Timestamp of sample deletion"
    )
    created: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime, comment="Timestamp of sample creation"
    )
    name: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    reference_genome: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    organism: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    accession_number: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="A unique identifier generated by the INSDC"
    )
    common_name: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    description: Mapped[Optional[str]] = mapped_column(TEXT)
    taxon_id: Mapped[Optional[int]] = mapped_column(INTEGER)
    father: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    mother: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    replicate: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    ethnicity: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    gender: Mapped[Optional[str]] = mapped_column(VARCHAR(20))
    cohort: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    country_of_origin: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    geographical_region: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    sanger_sample_id: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    control: Mapped[Optional[int]] = mapped_column(TINYINT(1))
    supplier_name: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    public_name: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    sample_visibility: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    strain: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    donor_id: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    phenotype: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255),
        comment="The phenotype of the sample as described in Sequencescape",
    )
    developmental_stage: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="Developmental Stage"
    )
    control_type: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    sibling: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    is_resubmitted: Mapped[Optional[int]] = mapped_column(TINYINT(1))
    date_of_sample_collection: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    date_of_sample_extraction: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    extraction_method: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    purified: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    purification_method: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    customer_measured_concentration: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    concentration_determined_by: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    sample_type: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    storage_conditions: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    genotype: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    age: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    cell_type: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    disease_state: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    compound: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    dose: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    immunoprecipitate: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    growth_condition: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    organism_part: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    time_point: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    disease: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    subject: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    treatment: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    date_of_consent_withdrawn: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime
    )
    marked_as_consent_withdrawn_by: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    customer_measured_volume: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    gc_content: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    dna_source: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    priority_level: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="Priority level eg Medium, High etc"
    )

    bmap_flowcell: Mapped[list["BmapFlowcell"]] = relationship(
        "BmapFlowcell", back_populates="sample"
    )
    eseq_flowcell: Mapped[list["EseqFlowcell"]] = relationship(
        "EseqFlowcell", back_populates="sample"
    )
    flgen_plate: Mapped[list["FlgenPlate"]] = relationship(
        "FlgenPlate", back_populates="sample"
    )
    gsu_sample_uploads: Mapped[list["GsuSampleUploads"]] = relationship(
        "GsuSampleUploads", back_populates="sample"
    )
    iseq_flowcell: Mapped[list["IseqFlowcell"]] = relationship(
        "IseqFlowcell", back_populates="sample"
    )
    oseq_flowcell: Mapped[list["OseqFlowcell"]] = relationship(
        "OseqFlowcell", back_populates="sample"
    )
    pac_bio_run: Mapped[list["PacBioRun"]] = relationship(
        "PacBioRun", back_populates="sample"
    )
    qc_result: Mapped[list["QcResult"]] = relationship(
        "QcResult", back_populates="sample"
    )
    samples_extraction_activity: Mapped[list["SamplesExtractionActivity"]] = (
        relationship("SamplesExtractionActivity", back_populates="sample")
    )
    stock_resource: Mapped[list["StockResource"]] = relationship(
        "StockResource", back_populates="sample"
    )
    tol_sample_bioproject: Mapped[list["TolSampleBioproject"]] = relationship(
        "TolSampleBioproject", back_populates="sample"
    )
    useq_wafer: Mapped[list["UseqWafer"]] = relationship(
        "UseqWafer", back_populates="sample"
    )


t_schema_migrations = Table(
    "schema_migrations",
    Base.metadata,
    Column("version", VARCHAR(255), nullable=False),
    Index("unique_schema_migrations", "version", unique=True),
)


class SeqProductIrodsLocations(Base):
    __tablename__ = "seq_product_irods_locations"
    __table_args__ = (
        Index("pi_id_product", "id_product"),
        Index("pi_pipeline_name", "pipeline_name"),
        Index("pi_root_product", "irods_root_collection", "id_product", unique=True),
        Index("pi_seq_platform_name", "seq_platform_name"),
        {"comment": "Table relating products to their irods locations"},
    )

    id_seq_product_irods_locations_tmp: Mapped[int] = mapped_column(
        BIGINT,
        primary_key=True,
        comment="Internal to this database id, value can change",
    )
    id_product: Mapped[str] = mapped_column(
        VARCHAR(64),
        nullable=False,
        comment="A sequencing platform specific product id. For Illumina, data corresponds to the id_iseq_product column in the iseq_product_metrics table",
    )
    seq_platform_name: Mapped[str] = mapped_column(
        Enum("Illumina", "PacBio", "ONT", "Elembio", "Ultimagen"),
        nullable=False,
        comment="Name of the sequencing platform used to produce raw data",
    )
    pipeline_name: Mapped[str] = mapped_column(
        String(32),
        nullable=False,
        comment="The name of the pipeline used to produce the data, values are: npg-prod, npg-prod-alt-process, cellranger, spaceranger, ncov2019-artic-nf",
    )
    irods_root_collection: Mapped[str] = mapped_column(
        String(255),
        nullable=False,
        comment="Path to the product root collection in iRODS",
    )
    created: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime,
        server_default=text("CURRENT_TIMESTAMP"),
        comment="Datetime this record was created",
    )
    last_changed: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime,
        server_default=text("CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP"),
        comment="Datetime this record was created or changed",
    )
    irods_data_relative_path: Mapped[Optional[str]] = mapped_column(
        String(255),
        comment="The path, relative to the root collection, to the most used data location",
    )
    irods_secondary_data_relative_path: Mapped[Optional[str]] = mapped_column(
        String(255),
        comment="The path, relative to the root collection, to a useful data location",
    )


class StanSampleLabware(Base):
    __tablename__ = "stan_sample_labware"

    id_tmp: Mapped[int] = mapped_column(Integer, primary_key=True)
    barcode: Mapped[str] = mapped_column(VARCHAR(32), nullable=False)
    lw_type: Mapped[str] = mapped_column(VARCHAR(64), nullable=False)
    lw_created: Mapped[datetime.datetime] = mapped_column(TIMESTAMP, nullable=False)
    state: Mapped[str] = mapped_column(VARCHAR(9), nullable=False)
    slot_address: Mapped[str] = mapped_column(VARCHAR(8), nullable=False)
    bio_state: Mapped[str] = mapped_column(VARCHAR(64), nullable=False)
    sample_id: Mapped[int] = mapped_column(Integer, nullable=False)
    tissue_type: Mapped[str] = mapped_column(VARCHAR(64), nullable=False)
    spatial_location: Mapped[int] = mapped_column(Integer, nullable=False)
    donor_name: Mapped[str] = mapped_column(VARCHAR(64), nullable=False)
    species: Mapped[str] = mapped_column(VARCHAR(64), nullable=False)
    external_barcode: Mapped[Optional[str]] = mapped_column(VARCHAR(32))
    costing: Mapped[Optional[str]] = mapped_column(TEXT)
    section: Mapped[Optional[int]] = mapped_column(Integer)
    work_number: Mapped[Optional[str]] = mapped_column(TEXT)
    highest_section: Mapped[Optional[int]] = mapped_column(Integer)
    external_name: Mapped[Optional[str]] = mapped_column(VARCHAR(64))
    replicate: Mapped[Optional[str]] = mapped_column(VARCHAR(8))
    medium: Mapped[Optional[str]] = mapped_column(VARCHAR(64))
    fixative: Mapped[Optional[str]] = mapped_column(VARCHAR(64))
    humfre: Mapped[Optional[str]] = mapped_column(VARCHAR(16))
    life_stage: Mapped[Optional[str]] = mapped_column(VARCHAR(10))
    thickness: Mapped[Optional[str]] = mapped_column(TEXT)
    bio_risk: Mapped[Optional[str]] = mapped_column(VARCHAR(32))


class StanXenium(Base):
    __tablename__ = "stan_xenium"

    id_tmp: Mapped[int] = mapped_column(Integer, primary_key=True)
    xenium_analyser_op_id: Mapped[int] = mapped_column(Integer, nullable=False)
    xenium_analyser_performed: Mapped[datetime.datetime] = mapped_column(
        TIMESTAMP, nullable=False
    )
    run: Mapped[str] = mapped_column(VARCHAR(255), nullable=False)
    sample_id: Mapped[int] = mapped_column(Integer, nullable=False)
    slot_address: Mapped[str] = mapped_column(VARCHAR(8), nullable=False)
    barcode: Mapped[str] = mapped_column(VARCHAR(32), nullable=False)
    xenium_analyser_user: Mapped[str] = mapped_column(VARCHAR(32), nullable=False)
    cassette_position: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    decoding_reagent_A_lot: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    decoding_reagent_B_lot: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    decoding_consumables_lot: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    section: Mapped[Optional[int]] = mapped_column(Integer)
    roi: Mapped[Optional[str]] = mapped_column(VARCHAR(64))
    work_number: Mapped[Optional[str]] = mapped_column(VARCHAR(10))
    qc_op_id: Mapped[Optional[int]] = mapped_column(Integer)
    qc_perfomed: Mapped[Optional[datetime.datetime]] = mapped_column(TIMESTAMP)
    qc_comments: Mapped[Optional[str]] = mapped_column(TEXT)
    qc_user: Mapped[Optional[str]] = mapped_column(VARCHAR(32))
    equipment: Mapped[Optional[str]] = mapped_column(VARCHAR(64))


class Study(Base):
    __tablename__ = "study"
    __table_args__ = (
        Index("index_study_on_id_study_lims", "id_study_lims"),
        Index("study_accession_number_index", "accession_number"),
        Index(
            "study_id_lims_id_study_lims_index", "id_lims", "id_study_lims", unique=True
        ),
        Index("study_name_index", "name"),
        Index("study_uuid_study_lims_index", "uuid_study_lims", unique=True),
    )

    id_study_tmp: Mapped[int] = mapped_column(
        INTEGER,
        primary_key=True,
        comment="Internal to this database id, value can change",
    )
    id_lims: Mapped[str] = mapped_column(
        VARCHAR(10),
        nullable=False,
        comment="LIM system identifier, e.g. GCLP-CLARITY, SEQSCAPE",
    )
    id_study_lims: Mapped[str] = mapped_column(
        VARCHAR(20), nullable=False, comment="LIMS-specific study identifier"
    )
    last_updated: Mapped[datetime.datetime] = mapped_column(
        DateTime, nullable=False, comment="Timestamp of last update"
    )
    recorded_at: Mapped[datetime.datetime] = mapped_column(
        DateTime, nullable=False, comment="Timestamp of warehouse update"
    )
    remove_x_and_autosomes: Mapped[int] = mapped_column(
        TINYINT(1), nullable=False, server_default=text("'0'")
    )
    aligned: Mapped[int] = mapped_column(
        TINYINT(1), nullable=False, server_default=text("'1'")
    )
    separate_y_chromosome_data: Mapped[int] = mapped_column(
        TINYINT(1), nullable=False, server_default=text("'0'")
    )
    uuid_study_lims: Mapped[Optional[str]] = mapped_column(
        VARCHAR(36), comment="LIMS-specific study uuid"
    )
    deleted_at: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime, comment="Timestamp of study deletion"
    )
    created: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime, comment="Timestamp of study creation"
    )
    name: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    reference_genome: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    ethically_approved: Mapped[Optional[int]] = mapped_column(TINYINT(1))
    faculty_sponsor: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    state: Mapped[Optional[str]] = mapped_column(VARCHAR(50))
    study_type: Mapped[Optional[str]] = mapped_column(VARCHAR(50))
    abstract: Mapped[Optional[str]] = mapped_column(TEXT)
    abbreviation: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    accession_number: Mapped[Optional[str]] = mapped_column(VARCHAR(50))
    description: Mapped[Optional[str]] = mapped_column(TEXT)
    contains_human_dna: Mapped[Optional[int]] = mapped_column(
        TINYINT(1), comment="Lane may contain human DNA"
    )
    contaminated_human_dna: Mapped[Optional[int]] = mapped_column(
        TINYINT(1),
        comment="Human DNA in the lane is a contaminant and should be removed",
    )
    data_release_strategy: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    data_release_sort_of_study: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    ena_project_id: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    study_title: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    study_visibility: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    ega_dac_accession_number: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    array_express_accession_number: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    ega_policy_accession_number: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    data_release_timing: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    data_release_delay_period: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    data_release_delay_reason: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    data_access_group: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    prelim_id: Mapped[Optional[str]] = mapped_column(
        VARCHAR(20), comment="The preliminary study id prior to entry into the LIMS"
    )
    hmdmc_number: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255),
        comment="The Human Materials and Data Management Committee approval number(s) for the study.",
    )
    data_destination: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255),
        comment="The data destination type(s) for the study. It could be 'standard', '14mg' or 'gseq'. This may be extended, if Sanger gains more external customers. It can contain multiply destinations separated by a space.",
    )
    s3_email_list: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    data_deletion_period: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    contaminated_human_data_access_group: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255)
    )
    programme: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    ebi_library_strategy: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    ebi_library_source: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    ebi_library_selection: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    data_release_timing_publication_comment: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255)
    )
    data_share_in_preprint: Mapped[Optional[str]] = mapped_column(VARCHAR(255))

    bmap_flowcell: Mapped[list["BmapFlowcell"]] = relationship(
        "BmapFlowcell", back_populates="study"
    )
    eseq_flowcell: Mapped[list["EseqFlowcell"]] = relationship(
        "EseqFlowcell", back_populates="study"
    )
    flgen_plate: Mapped[list["FlgenPlate"]] = relationship(
        "FlgenPlate", back_populates="study"
    )
    gsu_sample_uploads: Mapped[list["GsuSampleUploads"]] = relationship(
        "GsuSampleUploads", back_populates="study"
    )
    iseq_flowcell: Mapped[list["IseqFlowcell"]] = relationship(
        "IseqFlowcell", back_populates="study"
    )
    oseq_flowcell: Mapped[list["OseqFlowcell"]] = relationship(
        "OseqFlowcell", back_populates="study"
    )
    pac_bio_run: Mapped[list["PacBioRun"]] = relationship(
        "PacBioRun", back_populates="study"
    )
    stock_resource: Mapped[list["StockResource"]] = relationship(
        "StockResource", back_populates="study"
    )
    study_users: Mapped[list["StudyUsers"]] = relationship(
        "StudyUsers", back_populates="study"
    )
    useq_wafer: Mapped[list["UseqWafer"]] = relationship(
        "UseqWafer", back_populates="study"
    )


class UseqRunMetrics(Base):
    __tablename__ = "useq_run_metrics"
    __table_args__ = (
        Index("useq_rf_name_index", "run_folder_name"),
        Index("useq_run_archived_index", "run_archived"),
    )

    id_run: Mapped[int] = mapped_column(
        INTEGER, primary_key=True, comment="NPG run identifier"
    )
    instrument_name: Mapped[str] = mapped_column(
        CHAR(32, collation="utf8mb3_unicode_ci"),
        nullable=False,
        comment="Instrument name in NPG tracking system",
    )
    instrument_external_name: Mapped[str] = mapped_column(
        String(255, "utf8mb3_unicode_ci"),
        nullable=False,
        comment="Name assigned to the instrument by the manufacturer",
    )
    instrument_model: Mapped[str] = mapped_column(
        String(255, "utf8mb3_unicode_ci"), nullable=False, comment="Instrument model"
    )
    run_folder_name: Mapped[str] = mapped_column(
        String(255, "utf8mb3_unicode_ci"),
        nullable=False,
        comment="Instrument run folder name",
    )
    cancelled: Mapped[int] = mapped_column(
        TINYINT,
        nullable=False,
        server_default=text("'0'"),
        comment="Boolean flag to indicate whether the run was failed in some way or its data has been discarded",
    )
    last_changed: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime,
        server_default=text("CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP"),
        comment="Date this record was created or changed",
    )
    ultimagen_Run_Id: Mapped[Optional[str]] = mapped_column(
        String(255, "utf8mb3_unicode_ci"), comment="Ultimagen  RunID"
    )
    ultimagen_Library_Pool: Mapped[Optional[str]] = mapped_column(
        String(255, "utf8mb3_unicode_ci"), comment="Ultimagen  Library_Pool"
    )
    run_priority: Mapped[Optional[int]] = mapped_column(TINYINT)
    run_in_progress: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime, comment="Timestamp of run in progress status"
    )
    run_archived: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime,
        comment="The date the run was released, ie QC-ed if applicable and fully archived",
    )
    qc_seq: Mapped[Optional[int]] = mapped_column(
        TINYINT(1),
        comment="Sequencing lane level QC outcome, a result of either manual or automatic assessment by core",
    )
    num_reads: Mapped[Optional[int]] = mapped_column(
        BIGINT, comment="Number of reads for this wafer"
    )
    input_num_reads: Mapped[Optional[int]] = mapped_column(
        BIGINT, comment="Number of input reads (before PF) for this wafer"
    )
    tags_decode_percent: Mapped[Optional[float]] = mapped_column(
        FLOAT,
        comment="An overall percent of pf reads assigned to expected barcodes and the control",
    )

    useq_product_metrics: Mapped[list["UseqProductMetrics"]] = relationship(
        "UseqProductMetrics", back_populates="useq_run_metrics"
    )


class BmapFlowcell(Base):
    __tablename__ = "bmap_flowcell"
    __table_args__ = (
        ForeignKeyConstraint(
            ["id_sample_tmp"],
            ["sample.id_sample_tmp"],
            ondelete="RESTRICT",
            onupdate="RESTRICT",
            name="fk_bmap_flowcell_to_sample",
        ),
        ForeignKeyConstraint(
            ["id_study_tmp"],
            ["study.id_study_tmp"],
            ondelete="RESTRICT",
            onupdate="RESTRICT",
            name="fk_bmap_flowcell_to_study",
        ),
        Index("fk_bmap_flowcell_to_sample", "id_sample_tmp"),
        Index("fk_bmap_flowcell_to_study", "id_study_tmp"),
        Index("index_bmap_flowcell_on_id_flowcell_lims", "id_flowcell_lims"),
        Index("index_bmap_flowcell_on_id_library_lims", "id_library_lims"),
    )

    id_bmap_flowcell_tmp: Mapped[int] = mapped_column(Integer, primary_key=True)
    last_updated: Mapped[datetime.datetime] = mapped_column(
        DateTime, nullable=False, comment="Timestamp of last update"
    )
    recorded_at: Mapped[datetime.datetime] = mapped_column(
        DateTime, nullable=False, comment="Timestamp of warehouse update"
    )
    id_sample_tmp: Mapped[int] = mapped_column(
        INTEGER, nullable=False, comment='Sample id, see "sample.id_sample_tmp"'
    )
    id_study_tmp: Mapped[int] = mapped_column(
        INTEGER, nullable=False, comment='Study id, see "study.id_study_tmp"'
    )
    experiment_name: Mapped[str] = mapped_column(
        String(255),
        nullable=False,
        comment="The name of the experiment, eg. The lims generated run id",
    )
    instrument_name: Mapped[str] = mapped_column(
        String(255),
        nullable=False,
        comment="The name of the instrument on which the sample was run",
    )
    enzyme_name: Mapped[str] = mapped_column(
        String(255), nullable=False, comment="The name of the recognition enzyme used"
    )
    chip_barcode: Mapped[str] = mapped_column(
        String(255), nullable=False, comment="Manufacturer chip identifier"
    )
    id_flowcell_lims: Mapped[str] = mapped_column(
        String(255), nullable=False, comment="LIMs-specific flowcell id"
    )
    id_lims: Mapped[str] = mapped_column(
        String(10), nullable=False, comment="LIM system identifier"
    )
    chip_serialnumber: Mapped[Optional[str]] = mapped_column(
        String(16), comment="Manufacturer chip identifier"
    )
    position: Mapped[Optional[int]] = mapped_column(
        INTEGER, comment="Flowcell position"
    )
    id_library_lims: Mapped[Optional[str]] = mapped_column(
        String(255), comment="Earliest LIMs identifier associated with library creation"
    )

    sample: Mapped["Sample"] = relationship("Sample", back_populates="bmap_flowcell")
    study: Mapped["Study"] = relationship("Study", back_populates="bmap_flowcell")


class EseqFlowcell(Base):
    __tablename__ = "eseq_flowcell"
    __table_args__ = (
        ForeignKeyConstraint(
            ["id_sample_tmp"], ["sample.id_sample_tmp"], name="eseq_flowcell_sample_fk"
        ),
        ForeignKeyConstraint(
            ["id_study_tmp"], ["study.id_study_tmp"], name="eseq_flowcell_study_fk"
        ),
        Index("eseq_flowcell_sample_fk", "id_sample_tmp"),
        Index("eseq_flowcell_study_fk", "id_study_tmp"),
        Index(
            "index_eseq_flowcell_on_composition_keys",
            "id_flowcell_lims",
            "lane",
            "tag_sequence",
            "tag2_sequence",
            "id_lims",
            unique=True,
        ),
        Index("index_eseq_flowcell_on_id_library_lims", "id_library_lims"),
        Index("index_eseq_flowcell_on_id_pool_lims", "id_pool_lims"),
    )

    id_eseq_flowcell_tmp: Mapped[int] = mapped_column(
        INTEGER,
        primary_key=True,
        comment="Internal to this database, id value can change",
    )
    id_flowcell_lims: Mapped[str] = mapped_column(
        VARCHAR(255),
        nullable=False,
        comment="LIMs-specific flowcell id, batch_id for Sequencescape",
    )
    last_updated: Mapped[datetime.datetime] = mapped_column(
        DateTime, nullable=False, comment="Timestamp of last update"
    )
    recorded_at: Mapped[datetime.datetime] = mapped_column(
        DateTime, nullable=False, comment="Timestamp of warehouse update"
    )
    id_sample_tmp: Mapped[int] = mapped_column(
        INTEGER, nullable=False, comment='Sample id, see "sample.id_sample_tmp"'
    )
    id_study_tmp: Mapped[int] = mapped_column(
        INTEGER, nullable=False, comment='Study id, see "study.id_study_tmp"'
    )
    id_lims: Mapped[str] = mapped_column(
        VARCHAR(10),
        nullable=False,
        comment="LIM system identifier, e.g. CLARITY-GCLP, SEQSCAPE",
    )
    lane: Mapped[int] = mapped_column(
        SMALLINT, nullable=False, comment="Flowcell lane number, 1 or 2"
    )
    entity_type: Mapped[str] = mapped_column(
        VARCHAR(30),
        nullable=False,
        comment="Library type: library_indexed, library_indexed_spike",
    )
    id_pool_lims: Mapped[str] = mapped_column(
        VARCHAR(20),
        nullable=False,
        comment="Most specific LIMs identifier associated with the pool",
    )
    entity_id_lims: Mapped[str] = mapped_column(
        VARCHAR(20),
        nullable=False,
        comment="Most specific LIMs identifier associated with this lane or plex or spike",
    )
    tag_sequence: Mapped[Optional[str]] = mapped_column(
        VARCHAR(30), comment="Tag sequence"
    )
    tag2_sequence: Mapped[Optional[str]] = mapped_column(
        VARCHAR(30), comment="Tag sequence for tag 2"
    )
    pipeline_id_lims: Mapped[Optional[str]] = mapped_column(
        VARCHAR(60),
        comment="LIMs-specific pipeline identifier that unambiguously defines library type",
    )
    bait_name: Mapped[Optional[str]] = mapped_column(
        VARCHAR(50), comment="WTSI-wide name that uniquely identifies a bait set"
    )
    requested_insert_size_from: Mapped[Optional[int]] = mapped_column(
        INTEGER, comment="Requested insert size min value"
    )
    requested_insert_size_to: Mapped[Optional[int]] = mapped_column(
        INTEGER, comment="Requested insert size max value"
    )
    id_library_lims: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255),
        comment="Earliest LIMs identifier associated with library creation",
    )
    primer_panel: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="Primer Panel name"
    )

    sample: Mapped["Sample"] = relationship("Sample", back_populates="eseq_flowcell")
    study: Mapped["Study"] = relationship("Study", back_populates="eseq_flowcell")
    eseq_product_metrics: Mapped[list["EseqProductMetrics"]] = relationship(
        "EseqProductMetrics", back_populates="eseq_flowcell"
    )


class FlgenPlate(Base):
    __tablename__ = "flgen_plate"
    __table_args__ = (
        ForeignKeyConstraint(
            ["id_sample_tmp"], ["sample.id_sample_tmp"], name="flgen_plate_sample_fk"
        ),
        ForeignKeyConstraint(
            ["id_study_tmp"], ["study.id_study_tmp"], name="flgen_plate_study_fk"
        ),
        Index(
            "flgen_plate_id_lims_id_flgen_plate_lims_index",
            "id_lims",
            "id_flgen_plate_lims",
        ),
        Index("flgen_plate_sample_fk", "id_sample_tmp"),
        Index("flgen_plate_study_fk", "id_study_tmp"),
    )

    id_flgen_plate_tmp: Mapped[int] = mapped_column(
        INTEGER,
        primary_key=True,
        comment="Internal to this database id, value can change",
    )
    id_sample_tmp: Mapped[int] = mapped_column(
        INTEGER, nullable=False, comment='Sample id, see "sample.id_sample_tmp"'
    )
    id_study_tmp: Mapped[int] = mapped_column(
        INTEGER, nullable=False, comment='Study id, see "study.id_study_tmp"'
    )
    cost_code: Mapped[str] = mapped_column(
        VARCHAR(20), nullable=False, comment="Valid WTSI cost code"
    )
    id_lims: Mapped[str] = mapped_column(
        VARCHAR(10),
        nullable=False,
        comment="LIM system identifier, e.g. CLARITY-GCLP, SEQSCAPE",
    )
    last_updated: Mapped[datetime.datetime] = mapped_column(
        DateTime, nullable=False, comment="Timestamp of last update"
    )
    recorded_at: Mapped[datetime.datetime] = mapped_column(
        DateTime, nullable=False, comment="Timestamp of warehouse update"
    )
    plate_barcode: Mapped[int] = mapped_column(
        INTEGER, nullable=False, comment="Manufacturer (Fluidigm) chip barcode"
    )
    id_flgen_plate_lims: Mapped[str] = mapped_column(
        VARCHAR(20), nullable=False, comment="LIMs-specific plate id"
    )
    well_label: Mapped[str] = mapped_column(
        VARCHAR(10),
        nullable=False,
        comment="Manufactuer well identifier within a plate, S001-S192",
    )
    plate_barcode_lims: Mapped[Optional[str]] = mapped_column(
        VARCHAR(128), comment="LIMs-specific plate barcode"
    )
    plate_uuid_lims: Mapped[Optional[str]] = mapped_column(
        VARCHAR(36), comment="LIMs-specific plate uuid"
    )
    plate_size: Mapped[Optional[int]] = mapped_column(
        SmallInteger, comment="Total number of wells on a plate"
    )
    plate_size_occupied: Mapped[Optional[int]] = mapped_column(
        SmallInteger, comment="Number of occupied wells on a plate"
    )
    well_uuid_lims: Mapped[Optional[str]] = mapped_column(
        VARCHAR(36), comment="LIMs-specific well uuid"
    )
    qc_state: Mapped[Optional[int]] = mapped_column(
        TINYINT(1), comment="QC state; 1 (pass), 0 (fail), NULL (not known)"
    )

    sample: Mapped["Sample"] = relationship("Sample", back_populates="flgen_plate")
    study: Mapped["Study"] = relationship("Study", back_populates="flgen_plate")


class GsuSampleUploads(Base):
    __tablename__ = "gsu_sample_uploads"
    __table_args__ = (
        ForeignKeyConstraint(
            ["id_sample_tmp"],
            ["sample.id_sample_tmp"],
            ondelete="RESTRICT",
            onupdate="RESTRICT",
            name="gsu_su_sample_fk",
        ),
        ForeignKeyConstraint(
            ["id_study_tmp"],
            ["study.id_study_tmp"],
            ondelete="RESTRICT",
            onupdate="RESTRICT",
            name="gsu_su_study_fk",
        ),
        Index("gsu_su_file_path_unq", "file_path", unique=True),
        Index("gsu_su_run_accession", "run_accession", unique=True),
        Index("gsu_su_sample", "id_sample_tmp"),
        Index("gsu_su_study", "id_study_tmp"),
    )

    id_gsu_sample_upload_tmp: Mapped[int] = mapped_column(
        INTEGER, primary_key=True, comment="Row ID"
    )
    file_path: Mapped[str] = mapped_column(
        VARCHAR(255), nullable=False, comment="Location of data file"
    )
    library_type: Mapped[str] = mapped_column(
        VARCHAR(40), nullable=False, comment="Library type"
    )
    instrument_model: Mapped[str] = mapped_column(
        VARCHAR(40), nullable=False, comment="Sequencing machine used"
    )
    lab_name: Mapped[str] = mapped_column(
        VARCHAR(100), nullable=False, comment="Lab supplying the data"
    )
    ena_upload: Mapped[int] = mapped_column(
        TINYINT(1),
        nullable=False,
        server_default=text("'0'"),
        comment="Identifies if the sample is eligible for ENA upload",
    )
    created: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime,
        server_default=text("CURRENT_TIMESTAMP"),
        comment="Datetime this record was created",
    )
    last_changed: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime,
        server_default=text("CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP"),
        comment="Datetime this record was last updated",
    )
    id_study_tmp: Mapped[Optional[int]] = mapped_column(
        INTEGER, comment="Study for this item"
    )
    id_sample_tmp: Mapped[Optional[int]] = mapped_column(
        INTEGER, comment="Sample info for this item"
    )
    library_name: Mapped[Optional[str]] = mapped_column(
        VARCHAR(40), comment="Supplier library name"
    )
    run_accession: Mapped[Optional[str]] = mapped_column(
        VARCHAR(40), comment="ENA run accession, populated on ENA submission"
    )

    sample: Mapped[Optional["Sample"]] = relationship(
        "Sample", back_populates="gsu_sample_uploads"
    )
    study: Mapped[Optional["Study"]] = relationship(
        "Study", back_populates="gsu_sample_uploads"
    )


class IseqExternalProductComponents(Base):
    __tablename__ = "iseq_external_product_components"
    __table_args__ = (
        ForeignKeyConstraint(
            ["id_iseq_product_ext"],
            ["iseq_external_product_metrics.id_iseq_product"],
            name="id_iseq_product_ext_digest_fk",
        ),
        Index("iseq_ext_pr_comp_compi", "component_index", "num_components"),
        Index("iseq_ext_pr_comp_ncomp", "num_components", "id_iseq_product"),
        Index("iseq_ext_pr_comp_pr_comp_fk", "id_iseq_product_ext"),
        Index(
            "iseq_ext_pr_comp_unique",
            "id_iseq_product",
            "id_iseq_product_ext",
            unique=True,
        ),
        {
            "comment": "Table linking iseq_external_product_metrics table products to "
            "components in the iseq_product_metrics table"
        },
    )

    id_iseq_ext_pr_components_tmp: Mapped[int] = mapped_column(
        BIGINT,
        primary_key=True,
        comment="Internal to this database id, value can change",
    )
    id_iseq_product_ext: Mapped[str] = mapped_column(
        CHAR(64),
        nullable=False,
        comment="id (digest) for the external product composition",
    )
    id_iseq_product: Mapped[str] = mapped_column(
        CHAR(64),
        nullable=False,
        comment="id (digest) for one of the products components",
    )
    num_components: Mapped[int] = mapped_column(
        TINYINT, nullable=False, comment="Number of component products for this product"
    )
    component_index: Mapped[int] = mapped_column(
        TINYINT,
        nullable=False,
        comment="Unique component index within all components of this product, a value from 1 to the value of num_components column for this product",
    )

    iseq_external_product_metrics: Mapped["IseqExternalProductMetrics"] = relationship(
        "IseqExternalProductMetrics", back_populates="iseq_external_product_components"
    )


class IseqFlowcell(Base):
    __tablename__ = "iseq_flowcell"
    __table_args__ = (
        ForeignKeyConstraint(
            ["id_sample_tmp"], ["sample.id_sample_tmp"], name="iseq_flowcell_sample_fk"
        ),
        ForeignKeyConstraint(
            ["id_study_tmp"], ["study.id_study_tmp"], name="iseq_flowcell_study_fk"
        ),
        Index(
            "index_iseq_flowcell_id_flowcell_lims_position_tag_index_id_lims",
            "id_flowcell_lims",
            "position",
            "tag_index",
            "id_lims",
            unique=True,
        ),
        Index("index_iseq_flowcell_legacy_library_id", "legacy_library_id"),
        Index("index_iseq_flowcell_on_id_library_lims", "id_library_lims"),
        Index("index_iseq_flowcell_on_id_pool_lims", "id_pool_lims"),
        Index(
            "index_iseqflowcell__flowcell_barcode__position__tag_index",
            "flowcell_barcode",
            "position",
            "tag_index",
        ),
        Index(
            "index_iseqflowcell__id_flowcell_lims__position__tag_index",
            "id_flowcell_lims",
            "position",
            "tag_index",
        ),
        Index(
            "iseq_flowcell_id_lims_id_flowcell_lims_index",
            "id_lims",
            "id_flowcell_lims",
        ),
        Index("iseq_flowcell_sample_fk", "id_sample_tmp"),
        Index("iseq_flowcell_study_fk", "id_study_tmp"),
    )

    id_iseq_flowcell_tmp: Mapped[int] = mapped_column(
        INTEGER,
        primary_key=True,
        comment="Internal to this database id, value can change",
    )
    last_updated: Mapped[datetime.datetime] = mapped_column(
        DateTime, nullable=False, comment="Timestamp of last update"
    )
    recorded_at: Mapped[datetime.datetime] = mapped_column(
        DateTime, nullable=False, comment="Timestamp of warehouse update"
    )
    id_sample_tmp: Mapped[int] = mapped_column(
        INTEGER, nullable=False, comment='Sample id, see "sample.id_sample_tmp"'
    )
    id_lims: Mapped[str] = mapped_column(
        VARCHAR(10),
        nullable=False,
        comment="LIM system identifier, e.g. CLARITY-GCLP, SEQSCAPE",
    )
    id_flowcell_lims: Mapped[str] = mapped_column(
        VARCHAR(20),
        nullable=False,
        comment="LIMs-specific flowcell id, batch_id for Sequencescape",
    )
    position: Mapped[int] = mapped_column(
        SMALLINT, nullable=False, comment="Flowcell lane number"
    )
    entity_type: Mapped[str] = mapped_column(
        VARCHAR(30),
        nullable=False,
        comment="Lane type: library, library_control, library_indexed, library_indexed_spike",
    )
    entity_id_lims: Mapped[str] = mapped_column(
        VARCHAR(20),
        nullable=False,
        comment="Most specific LIMs identifier associated with this lane or plex or spike",
    )
    is_spiked: Mapped[int] = mapped_column(
        TINYINT(1),
        nullable=False,
        server_default=text("'0'"),
        comment="Boolean flag indicating presence of a spike",
    )
    id_pool_lims: Mapped[str] = mapped_column(
        VARCHAR(20),
        nullable=False,
        comment="Most specific LIMs identifier associated with the pool",
    )
    id_study_tmp: Mapped[Optional[int]] = mapped_column(
        INTEGER, comment='Study id, see "study.id_study_tmp"'
    )
    cost_code: Mapped[Optional[str]] = mapped_column(
        VARCHAR(20), comment="Valid WTSI cost code"
    )
    is_r_and_d: Mapped[Optional[int]] = mapped_column(
        TINYINT(1),
        server_default=text("'0'"),
        comment="A boolean flag derived from cost code, flags RandD",
    )
    priority: Mapped[Optional[int]] = mapped_column(
        SMALLINT, server_default=text("'1'"), comment="Priority"
    )
    manual_qc: Mapped[Optional[int]] = mapped_column(
        TINYINT(1),
        comment="Legacy QC decision value set per lane which may be used for per-lane billing: iseq_product_metrics.qc is likely to contain the per product QC summary of use to most downstream users",
    )
    external_release: Mapped[Optional[int]] = mapped_column(
        TINYINT(1),
        comment="Defaults to manual qc value; can be changed by the user later",
    )
    flowcell_barcode: Mapped[Optional[str]] = mapped_column(
        VARCHAR(15), comment="Manufacturer flowcell barcode or other identifier"
    )
    tag_index: Mapped[Optional[int]] = mapped_column(
        SMALLINT, comment="Tag index, NULL if lane is not a pool"
    )
    tag_sequence: Mapped[Optional[str]] = mapped_column(
        VARCHAR(30), comment="Tag sequence"
    )
    tag_set_id_lims: Mapped[Optional[str]] = mapped_column(
        VARCHAR(20), comment="LIMs-specific identifier of the tag set"
    )
    tag_set_name: Mapped[Optional[str]] = mapped_column(
        VARCHAR(100), comment="WTSI-wide tag set name"
    )
    tag_identifier: Mapped[Optional[str]] = mapped_column(
        VARCHAR(30), comment="The position of tag within the tag group"
    )
    tag2_sequence: Mapped[Optional[str]] = mapped_column(
        VARCHAR(30), comment="Tag sequence for tag 2"
    )
    tag2_set_id_lims: Mapped[Optional[str]] = mapped_column(
        VARCHAR(20), comment="LIMs-specific identifier of the tag set for tag 2"
    )
    tag2_set_name: Mapped[Optional[str]] = mapped_column(
        VARCHAR(100), comment="WTSI-wide tag set name for tag 2"
    )
    tag2_identifier: Mapped[Optional[str]] = mapped_column(
        VARCHAR(30), comment="The position of tag2 within the tag group"
    )
    pipeline_id_lims: Mapped[Optional[str]] = mapped_column(
        VARCHAR(60),
        comment="LIMs-specific pipeline identifier that unambiguously defines library type",
    )
    bait_name: Mapped[Optional[str]] = mapped_column(
        VARCHAR(50), comment="WTSI-wide name that uniquely identifies a bait set"
    )
    requested_insert_size_from: Mapped[Optional[int]] = mapped_column(
        INTEGER, comment="Requested insert size min value"
    )
    requested_insert_size_to: Mapped[Optional[int]] = mapped_column(
        INTEGER, comment="Requested insert size max value"
    )
    forward_read_length: Mapped[Optional[int]] = mapped_column(
        SMALLINT, comment="Requested forward read length, bp"
    )
    reverse_read_length: Mapped[Optional[int]] = mapped_column(
        SMALLINT, comment="Requested reverse read length, bp"
    )
    legacy_library_id: Mapped[Optional[int]] = mapped_column(
        Integer, comment="Legacy library_id for backwards compatibility."
    )
    id_library_lims: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255),
        comment="Earliest LIMs identifier associated with library creation",
    )
    team: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="The team responsible for creating the flowcell"
    )
    purpose: Mapped[Optional[str]] = mapped_column(
        VARCHAR(30),
        comment="Describes the reason the sequencing was conducted. Eg. Standard, QC, Control",
    )
    suboptimal: Mapped[Optional[int]] = mapped_column(
        TINYINT(1),
        comment="Indicates that a sample has failed a QC step during processing",
    )
    primer_panel: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="Primer Panel name"
    )
    spiked_phix_barcode: Mapped[Optional[str]] = mapped_column(
        VARCHAR(20), comment="Barcode of the PhiX tube added to the lane"
    )
    spiked_phix_percentage: Mapped[Optional[float]] = mapped_column(
        Float,
        comment="Percentage PhiX tube spiked in the pool in terms of molar concentration",
    )
    loading_concentration: Mapped[Optional[float]] = mapped_column(
        Float, comment="Final instrument loading concentration (pM)"
    )
    workflow: Mapped[Optional[str]] = mapped_column(
        VARCHAR(20), comment="Workflow used when processing the flowcell"
    )

    sample: Mapped["Sample"] = relationship("Sample", back_populates="iseq_flowcell")
    study: Mapped[Optional["Study"]] = relationship(
        "Study", back_populates="iseq_flowcell"
    )
    iseq_product_metrics: Mapped[list["IseqProductMetrics"]] = relationship(
        "IseqProductMetrics", back_populates="iseq_flowcell"
    )


class IseqRunInfo(IseqRun):
    __tablename__ = "iseq_run_info"
    __table_args__ = (
        ForeignKeyConstraint(
            ["id_run"], ["iseq_run.id_run"], name="iseq_run_info_ibfk_1"
        ),
        {"comment": "Table storing selected text files from the run folder"},
    )

    id_run: Mapped[int] = mapped_column(
        INTEGER, primary_key=True, comment="NPG run identifier"
    )
    run_parameters_xml: Mapped[Optional[str]] = mapped_column(
        TEXT, comment="The contents of Illumina's {R,r}unParameters.xml file"
    )


class IseqRunStatus(Base):
    __tablename__ = "iseq_run_status"
    __table_args__ = (
        ForeignKeyConstraint(
            ["id_run_status_dict"],
            ["iseq_run_status_dict.id_run_status_dict"],
            name="iseq_run_status_rsd_fk",
        ),
        Index("id_run_status_id_run", "id_run"),
        Index("iseq_run_status_rsd_fk", "id_run_status_dict"),
    )

    id_run_status: Mapped[int] = mapped_column(INTEGER, primary_key=True)
    id_run: Mapped[int] = mapped_column(
        INTEGER, nullable=False, comment="NPG run identifier"
    )
    date: Mapped[datetime.datetime] = mapped_column(
        DateTime, nullable=False, comment="Status timestamp"
    )
    id_run_status_dict: Mapped[int] = mapped_column(
        INTEGER,
        nullable=False,
        comment="Status identifier, see iseq_run_status_dict.id_run_status_dict",
    )
    iscurrent: Mapped[int] = mapped_column(
        TINYINT(1),
        nullable=False,
        comment="Boolean flag, 1 is the status is current, 0 otherwise",
    )

    iseq_run_status_dict: Mapped["IseqRunStatusDict"] = relationship(
        "IseqRunStatusDict", back_populates="iseq_run_status"
    )


class OseqFlowcell(Base):
    __tablename__ = "oseq_flowcell"
    __table_args__ = (
        ForeignKeyConstraint(
            ["id_sample_tmp"],
            ["sample.id_sample_tmp"],
            ondelete="RESTRICT",
            onupdate="RESTRICT",
            name="fk_oseq_flowcell_to_sample",
        ),
        ForeignKeyConstraint(
            ["id_study_tmp"],
            ["study.id_study_tmp"],
            ondelete="RESTRICT",
            onupdate="RESTRICT",
            name="fk_oseq_flowcell_to_study",
        ),
        Index("fk_oseq_flowcell_to_sample", "id_sample_tmp"),
        Index("fk_oseq_flowcell_to_study", "id_study_tmp"),
    )

    id_oseq_flowcell_tmp: Mapped[int] = mapped_column(INTEGER, primary_key=True)
    id_flowcell_lims: Mapped[str] = mapped_column(
        VARCHAR(255), nullable=False, comment="LIMs-specific flowcell id"
    )
    last_updated: Mapped[datetime.datetime] = mapped_column(
        DateTime, nullable=False, comment="Timestamp of last update"
    )
    recorded_at: Mapped[datetime.datetime] = mapped_column(
        DateTime, nullable=False, comment="Timestamp of warehouse update"
    )
    id_sample_tmp: Mapped[int] = mapped_column(
        INTEGER, nullable=False, comment='Sample id, see "sample.id_sample_tmp"'
    )
    id_study_tmp: Mapped[int] = mapped_column(
        INTEGER, nullable=False, comment='Study id, see "study.id_study_tmp"'
    )
    experiment_name: Mapped[str] = mapped_column(
        VARCHAR(255),
        nullable=False,
        comment="The name of the experiment, eg. The lims generated run id",
    )
    instrument_name: Mapped[str] = mapped_column(
        VARCHAR(255),
        nullable=False,
        comment="The name of the instrument on which the sample was run",
    )
    instrument_slot: Mapped[int] = mapped_column(
        Integer,
        nullable=False,
        comment="The numeric identifier of the slot on which the sample was run",
    )
    id_lims: Mapped[str] = mapped_column(
        VARCHAR(10), nullable=False, comment="LIM system identifier"
    )
    pipeline_id_lims: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255),
        comment="LIMs-specific pipeline identifier that unambiguously defines library type",
    )
    requested_data_type: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255),
        comment="The type of data produced by sequencing, eg. basecalls only",
    )
    deleted_at: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime, comment="Timestamp of any flowcell destruction"
    )
    tag_identifier: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="Position of the first tag within the tag group"
    )
    tag_sequence: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="Sequence of the first tag"
    )
    tag_set_id_lims: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255),
        comment="LIMs-specific identifier of the tag set for the first tag",
    )
    tag_set_name: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="WTSI-wide tag set name for the first tag"
    )
    tag2_identifier: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="Position of the second tag within the tag group"
    )
    tag2_sequence: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="Sequence of the second tag"
    )
    tag2_set_id_lims: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255),
        comment="LIMs-specific identifier of the tag set for the second tag",
    )
    tag2_set_name: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="WTSI-wide tag set name for the second tag"
    )
    flowcell_id: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255),
        comment="The id of the flowcell. Supplied with the flowcell. Format FAVnnnn",
    )
    library_tube_uuid: Mapped[Optional[str]] = mapped_column(
        VARCHAR(36), comment="The uuid for the originating library tube"
    )
    library_tube_barcode: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="The barcode for the originating library tube"
    )
    run_uuid: Mapped[Optional[str]] = mapped_column(
        VARCHAR(36), comment="The uuid of the run"
    )
    run_id: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="Run identifier assigned by MinKNOW"
    )
    rebasecalling_process: Mapped[Optional[str]] = mapped_column(
        VARCHAR(50), comment="Settings required for modified basecalling"
    )

    sample: Mapped["Sample"] = relationship("Sample", back_populates="oseq_flowcell")
    study: Mapped["Study"] = relationship("Study", back_populates="oseq_flowcell")


class PacBioRun(Base):
    __tablename__ = "pac_bio_run"
    __table_args__ = (
        ForeignKeyConstraint(
            ["id_sample_tmp"],
            ["sample.id_sample_tmp"],
            ondelete="RESTRICT",
            onupdate="RESTRICT",
            name="fk_pac_bio_run_to_sample",
        ),
        ForeignKeyConstraint(
            ["id_study_tmp"],
            ["study.id_study_tmp"],
            ondelete="RESTRICT",
            onupdate="RESTRICT",
            name="fk_pac_bio_run_to_study",
        ),
        Index("fk_pac_bio_run_to_sample", "id_sample_tmp"),
        Index("fk_pac_bio_run_to_study", "id_study_tmp"),
        Index(
            "unique_pac_bio_entry",
            "id_lims",
            "id_pac_bio_run_lims",
            "well_label",
            "comparable_tag_identifier",
            "comparable_tag2_identifier",
            "plate_number",
            unique=True,
        ),
    )

    id_pac_bio_tmp: Mapped[int] = mapped_column(Integer, primary_key=True)
    last_updated: Mapped[datetime.datetime] = mapped_column(
        DateTime, nullable=False, comment="Timestamp of last update"
    )
    recorded_at: Mapped[datetime.datetime] = mapped_column(
        DateTime, nullable=False, comment="Timestamp of warehouse update"
    )
    id_sample_tmp: Mapped[int] = mapped_column(
        INTEGER, nullable=False, comment='Sample id, see "sample.id_sample_tmp"'
    )
    id_study_tmp: Mapped[int] = mapped_column(
        INTEGER, nullable=False, comment='Sample id, see "study.id_study_tmp"'
    )
    id_pac_bio_run_lims: Mapped[str] = mapped_column(
        VARCHAR(20),
        nullable=False,
        comment="Lims specific identifier for the pacbio run",
    )
    cost_code: Mapped[str] = mapped_column(
        VARCHAR(20), nullable=False, comment="Valid WTSI cost-code"
    )
    id_lims: Mapped[str] = mapped_column(
        VARCHAR(10), nullable=False, comment="LIM system identifier"
    )
    plate_uuid_lims: Mapped[str] = mapped_column(
        VARCHAR(36), nullable=False, comment="The plate uuid"
    )
    well_label: Mapped[str] = mapped_column(
        VARCHAR(255),
        nullable=False,
        comment="The well identifier for the plate, A1-H12",
    )
    well_uuid_lims: Mapped[str] = mapped_column(
        VARCHAR(36), nullable=False, comment="The well uuid"
    )
    pac_bio_library_tube_id_lims: Mapped[str] = mapped_column(
        VARCHAR(255),
        nullable=False,
        comment="LIMS specific identifier for originating library tube",
    )
    pac_bio_library_tube_uuid: Mapped[str] = mapped_column(
        VARCHAR(255),
        nullable=False,
        comment="The uuid for the originating library tube",
    )
    pac_bio_library_tube_name: Mapped[str] = mapped_column(
        VARCHAR(255), nullable=False, comment="The name of the originating library tube"
    )
    pac_bio_run_uuid: Mapped[Optional[str]] = mapped_column(
        VARCHAR(36), comment="Uuid identifier for the pacbio run"
    )
    tag_identifier: Mapped[Optional[str]] = mapped_column(
        VARCHAR(30), comment="Tag index within tag set, NULL if untagged"
    )
    tag_sequence: Mapped[Optional[str]] = mapped_column(
        VARCHAR(50), comment="Tag sequence for tag"
    )
    tag_set_id_lims: Mapped[Optional[str]] = mapped_column(
        VARCHAR(20), comment="LIMs-specific identifier of the tag set for tag"
    )
    tag_set_name: Mapped[Optional[str]] = mapped_column(
        VARCHAR(100), comment="WTSI-wide tag set name for tag"
    )
    tag2_sequence: Mapped[Optional[str]] = mapped_column(VARCHAR(50))
    tag2_set_id_lims: Mapped[Optional[str]] = mapped_column(VARCHAR(20))
    tag2_set_name: Mapped[Optional[str]] = mapped_column(VARCHAR(100))
    tag2_identifier: Mapped[Optional[str]] = mapped_column(VARCHAR(30))
    plate_barcode: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255),
        comment="The human readable barcode for the plate loaded onto the machine",
    )
    pac_bio_library_tube_legacy_id: Mapped[Optional[int]] = mapped_column(
        Integer, comment="Legacy library_id for backwards compatibility."
    )
    library_created_at: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime, comment="Timestamp of library creation"
    )
    pac_bio_run_name: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="Name of the run"
    )
    pipeline_id_lims: Mapped[Optional[str]] = mapped_column(
        VARCHAR(60),
        comment="LIMS-specific pipeline identifier that unambiguously defines library type (eg. Sequel-v1, IsoSeq-v1)",
    )
    comparable_tag_identifier: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), Computed("(ifnull(`tag_identifier`,-(1)))", persisted=False)
    )
    comparable_tag2_identifier: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), Computed("(ifnull(`tag2_identifier`,-(1)))", persisted=False)
    )
    plate_number: Mapped[Optional[int]] = mapped_column(
        Integer,
        comment="The number of the plate that goes onto the sequencing machine. Necessary as an identifier for multi-plate support.",
    )
    pac_bio_library_tube_barcode: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="The barcode of the originating library tube"
    )

    sample: Mapped["Sample"] = relationship("Sample", back_populates="pac_bio_run")
    study: Mapped["Study"] = relationship("Study", back_populates="pac_bio_run")
    pac_bio_product_metrics: Mapped[list["PacBioProductMetrics"]] = relationship(
        "PacBioProductMetrics", back_populates="pac_bio_run"
    )


class QcResult(Base):
    __tablename__ = "qc_result"
    __table_args__ = (
        ForeignKeyConstraint(
            ["id_sample_tmp"],
            ["sample.id_sample_tmp"],
            ondelete="RESTRICT",
            onupdate="RESTRICT",
            name="fk_qc_result_to_sample",
        ),
        Index("fk_qc_result_to_sample", "id_sample_tmp"),
        Index("lookup_index", "id_qc_result_lims", "id_lims"),
        Index("qc_result_id_library_lims_index", "id_library_lims"),
    )

    id_qc_result_tmp: Mapped[int] = mapped_column(Integer, primary_key=True)
    id_sample_tmp: Mapped[int] = mapped_column(INTEGER, nullable=False)
    id_qc_result_lims: Mapped[str] = mapped_column(
        String(20), nullable=False, comment="LIMS-specific qc_result identifier"
    )
    id_lims: Mapped[str] = mapped_column(
        String(10),
        nullable=False,
        comment="LIMS system identifier (e.g. SEQUENCESCAPE)",
    )
    value: Mapped[str] = mapped_column(
        String(255), nullable=False, comment="Value of the mesurement"
    )
    units: Mapped[str] = mapped_column(
        String(255), nullable=False, comment="Mesurement unit"
    )
    qc_type: Mapped[str] = mapped_column(
        String(255), nullable=False, comment="Type of mesurement"
    )
    date_created: Mapped[datetime.datetime] = mapped_column(
        DateTime,
        nullable=False,
        comment="The date the qc_result was first created in SS",
    )
    last_updated: Mapped[datetime.datetime] = mapped_column(
        DateTime,
        nullable=False,
        comment="The date the qc_result was last updated in SS",
    )
    recorded_at: Mapped[datetime.datetime] = mapped_column(
        DateTime, nullable=False, comment="Timestamp of warehouse update"
    )
    id_pool_lims: Mapped[Optional[str]] = mapped_column(
        String(255),
        comment="Most specific LIMs identifier associated with the pool. (Asset external_identifier in SS)",
    )
    id_library_lims: Mapped[Optional[str]] = mapped_column(
        String(255),
        comment="Earliest LIMs identifier associated with library creation. (Aliquot external_identifier in SS)",
    )
    labware_purpose: Mapped[Optional[str]] = mapped_column(
        String(255), comment="Labware Purpose name. (e.g. Plate Purpose for a Well)"
    )
    assay: Mapped[Optional[str]] = mapped_column(
        String(255), comment="assay type and version"
    )
    cv: Mapped[Optional[float]] = mapped_column(
        Float, comment="Coefficient of variance"
    )

    sample: Mapped["Sample"] = relationship("Sample", back_populates="qc_result")


class SamplesExtractionActivity(Base):
    __tablename__ = "samples_extraction_activity"
    __table_args__ = (
        ForeignKeyConstraint(
            ["id_sample_tmp"],
            ["sample.id_sample_tmp"],
            ondelete="RESTRICT",
            onupdate="RESTRICT",
            name="fk_rails_bbdd0468f0",
        ),
        Index("fk_rails_bbdd0468f0", "id_sample_tmp"),
        Index(
            "index_samples_extraction_activity_on_id_activity_lims", "id_activity_lims"
        ),
    )

    id_activity_tmp: Mapped[int] = mapped_column(Integer, primary_key=True)
    id_activity_lims: Mapped[str] = mapped_column(
        VARCHAR(255), nullable=False, comment="LIMs-specific activity id"
    )
    id_sample_tmp: Mapped[int] = mapped_column(
        INTEGER, nullable=False, comment='Sample id, see "sample.id_sample_tmp"'
    )
    activity_type: Mapped[str] = mapped_column(
        VARCHAR(255), nullable=False, comment="The type of the activity performed"
    )
    instrument: Mapped[str] = mapped_column(
        VARCHAR(255),
        nullable=False,
        comment="The name of the instrument used to perform the activity",
    )
    kit_barcode: Mapped[str] = mapped_column(
        VARCHAR(255),
        nullable=False,
        comment="The barcode of the kit used to perform the activity",
    )
    kit_type: Mapped[str] = mapped_column(
        VARCHAR(255),
        nullable=False,
        comment="The type of kit used to perform the activity",
    )
    input_barcode: Mapped[str] = mapped_column(
        VARCHAR(255),
        nullable=False,
        comment="The barcode of the labware (eg. plate or tube) at the begining of the activity",
    )
    output_barcode: Mapped[str] = mapped_column(
        VARCHAR(255),
        nullable=False,
        comment="The barcode of the labware (eg. plate or tube)  at the end of the activity",
    )
    user: Mapped[str] = mapped_column(
        VARCHAR(255),
        nullable=False,
        comment="The name of the user who was most recently associated with the activity",
    )
    last_updated: Mapped[datetime.datetime] = mapped_column(
        DateTime, nullable=False, comment="Timestamp of last change to activity"
    )
    recorded_at: Mapped[datetime.datetime] = mapped_column(
        DateTime, nullable=False, comment="Timestamp of warehouse update"
    )
    completed_at: Mapped[datetime.datetime] = mapped_column(
        DateTime, nullable=False, comment="Timestamp of activity completion"
    )
    id_lims: Mapped[str] = mapped_column(
        VARCHAR(10), nullable=False, comment="LIM system identifier"
    )
    deleted_at: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime, comment="Timestamp of any activity removal"
    )

    sample: Mapped["Sample"] = relationship(
        "Sample", back_populates="samples_extraction_activity"
    )


class StockResource(Base):
    __tablename__ = "stock_resource"
    __table_args__ = (
        ForeignKeyConstraint(
            ["id_sample_tmp"],
            ["sample.id_sample_tmp"],
            ondelete="RESTRICT",
            onupdate="RESTRICT",
            name="fk_stock_resource_to_sample",
        ),
        ForeignKeyConstraint(
            ["id_study_tmp"],
            ["study.id_study_tmp"],
            ondelete="RESTRICT",
            onupdate="RESTRICT",
            name="fk_stock_resource_to_study",
        ),
        Index(
            "composition_lookup_index",
            "id_stock_resource_lims",
            "id_sample_tmp",
            "id_lims",
        ),
        Index("fk_stock_resource_to_sample", "id_sample_tmp"),
        Index("fk_stock_resource_to_study", "id_study_tmp"),
        Index("index_stock_resource_on_labware_human_barcode", "labware_human_barcode"),
    )

    id_stock_resource_tmp: Mapped[int] = mapped_column(Integer, primary_key=True)
    last_updated: Mapped[datetime.datetime] = mapped_column(
        DateTime, nullable=False, comment="Timestamp of last update"
    )
    recorded_at: Mapped[datetime.datetime] = mapped_column(
        DateTime, nullable=False, comment="Timestamp of warehouse update"
    )
    created: Mapped[datetime.datetime] = mapped_column(
        DateTime,
        nullable=False,
        comment="Timestamp of initial registration of stock in LIMS",
    )
    id_sample_tmp: Mapped[int] = mapped_column(
        INTEGER, nullable=False, comment='Sample id, see "sample.id_sample_tmp"'
    )
    id_study_tmp: Mapped[int] = mapped_column(
        INTEGER, nullable=False, comment='Sample id, see "study.id_study_tmp"'
    )
    id_lims: Mapped[str] = mapped_column(
        VARCHAR(10), nullable=False, comment="LIM system identifier"
    )
    id_stock_resource_lims: Mapped[str] = mapped_column(
        VARCHAR(20), nullable=False, comment="Lims specific identifier for the stock"
    )
    labware_type: Mapped[str] = mapped_column(
        VARCHAR(255),
        nullable=False,
        comment="The type of labware containing the stock. eg. Well, Tube",
    )
    labware_machine_barcode: Mapped[str] = mapped_column(
        VARCHAR(255),
        nullable=False,
        comment="The barcode of the containing labware as read by a barcode scanner",
    )
    labware_human_barcode: Mapped[str] = mapped_column(
        VARCHAR(255),
        nullable=False,
        comment="The barcode of the containing labware in human readable format",
    )
    deleted_at: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime,
        comment="Timestamp of initial registration of deletion in parent LIMS. NULL if not deleted.",
    )
    stock_resource_uuid: Mapped[Optional[str]] = mapped_column(
        VARCHAR(36), comment="Uuid identifier for the stock"
    )
    labware_coordinate: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255),
        comment="For wells, the coordinate on the containing plate. Null for tubes.",
    )
    current_volume: Mapped[Optional[float]] = mapped_column(
        Float,
        comment="The current volume of material in microlitres based on measurements and know usage",
    )
    initial_volume: Mapped[Optional[float]] = mapped_column(
        Float,
        comment="The result of the initial volume measurement in microlitres conducted on the material",
    )
    concentration: Mapped[Optional[float]] = mapped_column(
        Float,
        comment="The concentration of material recorded in the lab in nanograms per microlitre",
    )
    gel_pass: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="The recorded result for the qel QC assay."
    )
    pico_pass: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255),
        comment="The recorded result for the pico green assay. A pass indicates a successful assay, not sufficient material.",
    )
    snp_count: Mapped[Optional[int]] = mapped_column(
        Integer, comment="The number of markers detected in genotyping assays"
    )
    measured_gender: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="The gender call base on the genotyping assay"
    )

    sample: Mapped["Sample"] = relationship("Sample", back_populates="stock_resource")
    study: Mapped["Study"] = relationship("Study", back_populates="stock_resource")


class StudyUsers(Base):
    __tablename__ = "study_users"
    __table_args__ = (
        ForeignKeyConstraint(
            ["id_study_tmp"], ["study.id_study_tmp"], name="study_users_study_fk"
        ),
        Index("study_users_study_fk", "id_study_tmp"),
    )

    id_study_users_tmp: Mapped[int] = mapped_column(
        INTEGER,
        primary_key=True,
        comment="Internal to this database id, value can change",
    )
    id_study_tmp: Mapped[int] = mapped_column(
        INTEGER, nullable=False, comment='Study id, see "study.id_study_tmp"'
    )
    last_updated: Mapped[datetime.datetime] = mapped_column(
        DateTime, nullable=False, comment="Timestamp of last update"
    )
    role: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    login: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    email: Mapped[Optional[str]] = mapped_column(VARCHAR(255))
    name: Mapped[Optional[str]] = mapped_column(VARCHAR(255))

    study: Mapped["Study"] = relationship("Study", back_populates="study_users")


class TolSampleBioproject(Base):
    __tablename__ = "tol_sample_bioproject"
    __table_args__ = (
        ForeignKeyConstraint(
            ["id_sample_tmp"],
            ["sample.id_sample_tmp"],
            ondelete="SET NULL",
            onupdate="RESTRICT",
            name="fk_tsb_to_sample",
        ),
        Index("fk_tsb_to_sample", "id_sample_tmp"),
        Index("tol_sample_bioproject_file_index", "file", unique=True),
    )

    id_tsb_tmp: Mapped[int] = mapped_column(INTEGER, primary_key=True)
    date_added: Mapped[datetime.datetime] = mapped_column(
        TIMESTAMP, nullable=False, server_default=text("CURRENT_TIMESTAMP")
    )
    date_updated: Mapped[datetime.datetime] = mapped_column(
        TIMESTAMP,
        nullable=False,
        server_default=text("CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP"),
    )
    id_sample_tmp: Mapped[Optional[int]] = mapped_column(INTEGER)
    file: Mapped[Optional[str]] = mapped_column(String(255))
    library_type: Mapped[Optional[str]] = mapped_column(
        Enum(
            "Chromium genome",
            "Haplotagging",
            "Hi-C",
            "Hi-C - Arima v1",
            "Hi-C - Arima v2",
            "Hi-C - Dovetail",
            "Hi-C - Omni-C",
            "Hi-C - Qiagen",
            "PacBio - CLR",
            "PacBio - HiFi",
            "ONT",
            "RNA PolyA",
            "RNA-seq dUTP eukaryotic",
            "Standard",
            "unknown",
            "HiSeqX PCR free",
            "PacBio - HiFi (ULI)",
            "PacBio - IsoSeq",
            "ATAC-seq",
            "PacBio - HiFi (PiMmS)",
        )
    )
    tolid: Mapped[Optional[str]] = mapped_column(String(40))
    biosample_accession: Mapped[Optional[str]] = mapped_column(String(255))
    bioproject_accession: Mapped[Optional[str]] = mapped_column(String(255))
    filename: Mapped[Optional[str]] = mapped_column(String(255))

    sample: Mapped[Optional["Sample"]] = relationship(
        "Sample", back_populates="tol_sample_bioproject"
    )


class UseqWafer(Base):
    __tablename__ = "useq_wafer"
    __table_args__ = (
        ForeignKeyConstraint(
            ["id_sample_tmp"], ["sample.id_sample_tmp"], name="useq_wafer_sample_fk"
        ),
        ForeignKeyConstraint(
            ["id_study_tmp"], ["study.id_study_tmp"], name="useq_wafer_study_fk"
        ),
        Index(
            "index_useq_wafer_on_composition_keys",
            "batch_for_opentrons",
            "request_order",
            "tag_sequence",
            "id_lims",
            unique=True,
        ),
        Index("index_useq_wafer_on_id_library_lims", "id_library_lims"),
        Index("index_useq_wafer_on_id_lims", "id_lims"),
        Index("index_useq_wafer_on_id_pool_lims", "id_pool_lims"),
        Index("useq_wafer_sample_fk", "id_sample_tmp"),
        Index("useq_wafer_study_fk", "id_study_tmp"),
    )

    id_useq_wafer_tmp: Mapped[int] = mapped_column(
        INTEGER,
        primary_key=True,
        comment="Internal to this database, id value can change",
    )
    last_updated: Mapped[datetime.datetime] = mapped_column(
        DateTime, nullable=False, comment="Timestamp of last update"
    )
    recorded_at: Mapped[datetime.datetime] = mapped_column(
        DateTime, nullable=False, comment="Timestamp of warehouse update"
    )
    id_sample_tmp: Mapped[int] = mapped_column(
        INTEGER, nullable=False, comment='Sample id, see "sample.id_sample_tmp"'
    )
    id_study_tmp: Mapped[int] = mapped_column(
        INTEGER, nullable=False, comment='Study id, see "study.id_study_tmp"'
    )
    id_wafer_lims: Mapped[str] = mapped_column(
        VARCHAR(60),
        nullable=False,
        comment="LIMs-specific wafer id, a concatenation of batch_for_opentrons, id_pool_lims and request_order",
    )
    batch_for_opentrons: Mapped[str] = mapped_column(
        VARCHAR(20),
        nullable=False,
        comment="LIMs-specific identifier, batch_id for Sequencescape",
    )
    id_lims: Mapped[str] = mapped_column(
        VARCHAR(10),
        nullable=False,
        comment="LIM system identifier, e.g. CLARITY-GCLP, SEQSCAPE",
    )
    request_order: Mapped[int] = mapped_column(
        SMALLINT,
        nullable=False,
        comment="LIMs-specific identifier for order in a batch",
    )
    entity_type: Mapped[str] = mapped_column(
        VARCHAR(30),
        nullable=False,
        comment="Entity type, e.g. library_indexed or in the future some other library type",
    )
    id_pool_lims: Mapped[str] = mapped_column(
        VARCHAR(20),
        nullable=False,
        comment="Most specific LIMs identifier associated with the pool",
    )
    entity_id_lims: Mapped[str] = mapped_column(
        VARCHAR(20),
        nullable=False,
        comment="Most specific LIMs identifier associated with this library",
    )
    tag_sequence: Mapped[Optional[str]] = mapped_column(
        VARCHAR(30), comment="Tag sequence"
    )
    pipeline_id_lims: Mapped[Optional[str]] = mapped_column(
        VARCHAR(60),
        comment="LIMs-specific pipeline identifier that unambiguously defines library type",
    )
    bait_name: Mapped[Optional[str]] = mapped_column(
        VARCHAR(50), comment="WTSI-wide name that uniquely identifies a bait set"
    )
    requested_insert_size_from: Mapped[Optional[int]] = mapped_column(
        INTEGER, comment="Requested insert size min value"
    )
    requested_insert_size_to: Mapped[Optional[int]] = mapped_column(
        INTEGER, comment="Requested insert size max value"
    )
    ot_recipe: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="Opentron recipe name: Flex or Free"
    )
    primer_panel: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="Primer Panel name"
    )
    id_library_lims: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255),
        comment="Earliest LIMs identifier associated with library creation",
    )
    otr_carrier_lot_number: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="Opentron carrier lot number"
    )
    otr_carrier_expiry: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime, comment="Opentron carrier expiry date"
    )
    otr_reaction_mix_7_lot_number: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="Opentron reaction mix 7 lot number"
    )
    otr_reaction_mix_7_expiry: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime, comment="Opentron reaction mix 7 expiry date"
    )
    otr_nfw_lot_number: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="Opentron NFW lot number"
    )
    otr_nfw_expiry: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime, comment="Opentron NFW expiry date"
    )
    otr_oil_lot_number: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="Opentron oil lot number"
    )
    otr_oil_expiry: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime, comment="Opentron oil expiry date"
    )
    otr_pipette_carousel: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="Opentron pipette carousel identifier"
    )
    otr_instrument_name: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="Opentron instrument name"
    )
    amp_assign_control_bead_tube: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="AMP assign control bead tube barcode"
    )
    amp_instrument_name: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255), comment="AMP instrument name"
    )

    sample: Mapped["Sample"] = relationship("Sample", back_populates="useq_wafer")
    study: Mapped["Study"] = relationship("Study", back_populates="useq_wafer")
    useq_product_metrics: Mapped[list["UseqProductMetrics"]] = relationship(
        "UseqProductMetrics", back_populates="useq_wafer"
    )


class EseqProductMetrics(Base):
    __tablename__ = "eseq_product_metrics"
    __table_args__ = (
        ForeignKeyConstraint(
            ["id_eseq_flowcell_tmp"],
            ["eseq_flowcell.id_eseq_flowcell_tmp"],
            ondelete="SET NULL",
            name="eseq_pr_metrics_flc_fk",
        ),
        ForeignKeyConstraint(
            ["id_run", "lane"],
            ["eseq_run_lane_metrics.id_run", "eseq_run_lane_metrics.lane"],
            ondelete="CASCADE",
            name="eseq_pr_metrics_lm_fk",
        ),
        Index("eseq_pm_run_lane_tag_index", "id_run", "lane", "tag_index"),
        Index("eseq_pm_seqcontrol_tag_index", "is_sequencing_control", "tag_index"),
        Index("eseq_pm_tagseq_index", "tag_sequence", "tag2_sequence"),
        Index("eseq_pr_metrics_flc_fk", "id_eseq_flowcell_tmp"),
        Index(
            "eseq_pr_metrics_product_tagseq_unique",
            "id_eseq_product",
            "tag_sequence",
            "tag2_sequence",
            unique=True,
        ),
        Index("eseq_sample_name", "elembio_SampleName"),
    )

    id_eseq_pr_metrics_tmp: Mapped[int] = mapped_column(
        BIGINT,
        primary_key=True,
        comment="Internal to this database id, value can change",
    )
    id_eseq_product: Mapped[str] = mapped_column(
        CHAR(64), nullable=False, comment="Product id"
    )
    id_run: Mapped[int] = mapped_column(
        INTEGER, nullable=False, comment="NPG run identifier"
    )
    last_changed: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime,
        server_default=text("CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP"),
        comment="Date this record was created or changed",
    )
    id_eseq_flowcell_tmp: Mapped[Optional[int]] = mapped_column(
        INTEGER, comment='Foreign key, see "eseq_flowcell.id_eseq_flowcell_tmp"'
    )
    lane: Mapped[Optional[int]] = mapped_column(
        SMALLINT, comment="Flowcell lane number"
    )
    tag_index: Mapped[Optional[int]] = mapped_column(
        SMALLINT,
        comment="Lane-specific sequential unique index for a set of barcodes used to tag libraries derived from the same sample",
    )
    eseq_composition_tmp: Mapped[Optional[str]] = mapped_column(
        VARCHAR(600),
        comment="JSON representation of the composition object, the column might be deleted in future",
    )
    elembio_SampleName: Mapped[Optional[str]] = mapped_column(
        VARCHAR(255),
        comment="Name the sample is deplexed under by Element Biosciences software, corresponds to elembio:SampleName iRODS metadata",
    )
    elembio_Project: Mapped[Optional[str]] = mapped_column(
        VARCHAR(10),
        comment="Project record for this library in Elembio output files. Ideally should correspond to study.id_study_lims",
    )
    is_sequencing_control: Mapped[Optional[int]] = mapped_column(
        TINYINT(1),
        server_default=text("'0'"),
        comment="A boolean flag. If true, this is PhiX control library",
    )
    tag_sequence: Mapped[Optional[str]] = mapped_column(
        VARCHAR(30), comment="Tag sequence used for deplexing the lane data, I1 read"
    )
    tag2_sequence: Mapped[Optional[str]] = mapped_column(
        VARCHAR(30), comment="Tag sequence used for deplexing the lane data, I2 read"
    )
    qc_seq: Mapped[Optional[int]] = mapped_column(
        TINYINT(1),
        comment="Sequencing lane level QC outcome, a result of either manual or automatic assessment by core",
    )
    qc_lib: Mapped[Optional[int]] = mapped_column(
        TINYINT(1),
        comment="Library QC outcome, a result of either manual or automatic assessment by core",
    )
    qc: Mapped[Optional[int]] = mapped_column(
        TINYINT(1),
        comment="Overall QC assessment outcome, a logical product (conjunction) of qc_seq and qc_lib values, defaults to the qc_seq value when qc_lib is not defined",
    )
    tag_decode_count: Mapped[Optional[int]] = mapped_column(
        BIGINT,
        comment="Number of polonies (reads) assigned to this library after deplexing",
    )
    tag_decode_percent: Mapped[Optional[float]] = mapped_column(
        FLOAT,
        comment="Percent of polonies (reads) in a lane, which is assigned to this library after deplexing",
    )

    eseq_flowcell: Mapped[Optional["EseqFlowcell"]] = relationship(
        "EseqFlowcell", back_populates="eseq_product_metrics"
    )
    eseq_run_lane_metrics: Mapped[Optional["EseqRunLaneMetrics"]] = relationship(
        "EseqRunLaneMetrics", back_populates="eseq_product_metrics"
    )


class IseqProductMetrics(Base):
    __tablename__ = "iseq_product_metrics"
    __table_args__ = (
        ForeignKeyConstraint(
            ["id_iseq_flowcell_tmp"],
            ["iseq_flowcell.id_iseq_flowcell_tmp"],
            ondelete="SET NULL",
            name="iseq_pr_metrics_flc_fk",
        ),
        ForeignKeyConstraint(
            ["id_run", "position"],
            ["iseq_run_lane_metrics.id_run", "iseq_run_lane_metrics.position"],
            ondelete="CASCADE",
            name="iseq_pr_metrics_lm_fk",
        ),
        Index("iseq_pm_fcid_run_pos_tag_index", "id_run", "position", "tag_index"),
        Index("iseq_pr_metrics_flc_fk", "id_iseq_flowcell_tmp"),
        Index("iseq_pr_metrics_product_unique", "id_iseq_product", unique=True),
    )

    id_iseq_pr_metrics_tmp: Mapped[int] = mapped_column(
        BIGINT,
        primary_key=True,
        comment="Internal to this database id, value can change",
    )
    id_iseq_product: Mapped[str] = mapped_column(
        CHAR(64), nullable=False, comment="Product id"
    )
    last_changed: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime,
        server_default=text("CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP"),
        comment="Date this record was created or changed",
    )
    id_iseq_flowcell_tmp: Mapped[Optional[int]] = mapped_column(
        INTEGER, comment='Flowcell id, see "iseq_flowcell.id_iseq_flowcell_tmp"'
    )
    id_run: Mapped[Optional[int]] = mapped_column(INTEGER, comment="NPG run identifier")
    position: Mapped[Optional[int]] = mapped_column(
        SMALLINT, comment="Flowcell lane number"
    )
    tag_index: Mapped[Optional[int]] = mapped_column(
        SMALLINT, comment="Tag index, NULL if lane is not a pool"
    )
    iseq_composition_tmp: Mapped[Optional[str]] = mapped_column(
        VARCHAR(600),
        comment="JSON representation of the composition object, the column might be deleted in future",
    )
    qc_seq: Mapped[Optional[int]] = mapped_column(
        TINYINT(1),
        comment="Sequencing lane level QC outcome, a result of either manual or automatic assessment by core",
    )
    qc_lib: Mapped[Optional[int]] = mapped_column(
        TINYINT(1),
        comment="Library QC outcome, a result of either manual or automatic assessment by core",
    )
    qc_user: Mapped[Optional[int]] = mapped_column(
        TINYINT(1),
        comment="Library QC outcome according to the data user criteria, a result of either manual or automatic assessment",
    )
    qc: Mapped[Optional[int]] = mapped_column(
        TINYINT(1),
        comment="Overall QC assessment outcome, a logical product (conjunction) of qc_seq and qc_lib values, defaults to the qc_seq value when qc_lib is not defined",
    )
    tag_sequence4deplexing: Mapped[Optional[str]] = mapped_column(
        VARCHAR(30),
        comment="Tag sequence used for deplexing the lane, common suffix might have been truncated",
    )
    actual_forward_read_length: Mapped[Optional[int]] = mapped_column(
        SMALLINT, comment="Actual forward read length, bp"
    )
    actual_reverse_read_length: Mapped[Optional[int]] = mapped_column(
        SMALLINT, comment="Actual reverse read length, bp"
    )
    indexing_read_length: Mapped[Optional[int]] = mapped_column(
        SMALLINT, comment="Indexing read length, bp"
    )
    tag_decode_percent: Mapped[Optional[float]] = mapped_column(FLOAT(5, 2))
    tag_decode_count: Mapped[Optional[int]] = mapped_column(BIGINT)
    insert_size_quartile1: Mapped[Optional[int]] = mapped_column(SMALLINT)
    insert_size_quartile3: Mapped[Optional[int]] = mapped_column(SMALLINT)
    insert_size_median: Mapped[Optional[int]] = mapped_column(SMALLINT)
    insert_size_num_modes: Mapped[Optional[int]] = mapped_column(SMALLINT)
    insert_size_normal_fit_confidence: Mapped[Optional[float]] = mapped_column(
        FLOAT(3, 2)
    )
    gc_percent_forward_read: Mapped[Optional[float]] = mapped_column(FLOAT(5, 2))
    gc_percent_reverse_read: Mapped[Optional[float]] = mapped_column(FLOAT(5, 2))
    sequence_mismatch_percent_forward_read: Mapped[Optional[float]] = mapped_column(
        FLOAT(4, 2)
    )
    sequence_mismatch_percent_reverse_read: Mapped[Optional[float]] = mapped_column(
        FLOAT(4, 2)
    )
    adapters_percent_forward_read: Mapped[Optional[float]] = mapped_column(FLOAT(5, 2))
    adapters_percent_reverse_read: Mapped[Optional[float]] = mapped_column(FLOAT(5, 2))
    ref_match1_name: Mapped[Optional[str]] = mapped_column(VARCHAR(100))
    ref_match1_percent: Mapped[Optional[float]] = mapped_column(FLOAT(5, 2))
    ref_match2_name: Mapped[Optional[str]] = mapped_column(VARCHAR(100))
    ref_match2_percent: Mapped[Optional[float]] = mapped_column(FLOAT(5, 2))
    q20_yield_kb_forward_read: Mapped[Optional[int]] = mapped_column(INTEGER)
    q20_yield_kb_reverse_read: Mapped[Optional[int]] = mapped_column(INTEGER)
    q30_yield_kb_forward_read: Mapped[Optional[int]] = mapped_column(INTEGER)
    q30_yield_kb_reverse_read: Mapped[Optional[int]] = mapped_column(INTEGER)
    q40_yield_kb_forward_read: Mapped[Optional[int]] = mapped_column(INTEGER)
    q40_yield_kb_reverse_read: Mapped[Optional[int]] = mapped_column(INTEGER)
    num_reads: Mapped[Optional[int]] = mapped_column(BIGINT)
    percent_mapped: Mapped[Optional[float]] = mapped_column(FLOAT(5, 2))
    percent_duplicate: Mapped[Optional[float]] = mapped_column(FLOAT(5, 2))
    chimeric_reads_percent: Mapped[Optional[float]] = mapped_column(
        FLOAT(5, 2), comment="mate_mapped_defferent_chr_5 as percentage of all"
    )
    human_percent_mapped: Mapped[Optional[float]] = mapped_column(FLOAT(5, 2))
    human_percent_duplicate: Mapped[Optional[float]] = mapped_column(FLOAT(5, 2))
    genotype_sample_name_match: Mapped[Optional[str]] = mapped_column(VARCHAR(8))
    genotype_sample_name_relaxed_match: Mapped[Optional[str]] = mapped_column(
        VARCHAR(8)
    )
    genotype_mean_depth: Mapped[Optional[float]] = mapped_column(FLOAT(7, 2))
    mean_bait_coverage: Mapped[Optional[float]] = mapped_column(FLOAT(8, 2))
    on_bait_percent: Mapped[Optional[float]] = mapped_column(FLOAT(5, 2))
    on_or_near_bait_percent: Mapped[Optional[float]] = mapped_column(FLOAT(5, 2))
    mean_bait_target_coverage: Mapped[Optional[float]] = mapped_column(
        Float,
        comment="Mean coverage of the design target regions of a bait library (if used and known)",
    )
    verify_bam_id_average_depth: Mapped[Optional[float]] = mapped_column(FLOAT(11, 2))
    verify_bam_id_score: Mapped[Optional[float]] = mapped_column(FLOAT(6, 5))
    verify_bam_id_snp_count: Mapped[Optional[int]] = mapped_column(INTEGER)
    rna_exonic_rate: Mapped[Optional[float]] = mapped_column(
        FLOAT, comment="Exonic Rate is the fraction mapping within exons"
    )
    rna_percent_end_2_reads_sense: Mapped[Optional[float]] = mapped_column(
        FLOAT,
        comment="Percentage of intragenic End 2 reads that were sequenced in the sense direction.",
    )
    rna_rrna_rate: Mapped[Optional[float]] = mapped_column(
        FLOAT, comment="rRNA Rate is per total reads"
    )
    rna_genes_detected: Mapped[Optional[int]] = mapped_column(
        INTEGER, comment="Number of genes detected with at least 5 reads."
    )
    rna_norm_3_prime_coverage: Mapped[Optional[float]] = mapped_column(
        FLOAT,
        comment="3 prime n-based normalization: n is the transcript length at that end; norm is the ratio between the coverage at the 3 prime end and the average coverage of the full transcript, averaged over all transcripts",
    )
    rna_norm_5_prime_coverage: Mapped[Optional[float]] = mapped_column(
        FLOAT,
        comment="5 prime n-based normalization: n is the transcript length at that end; norm is the ratio between the coverage at the 5 prime end and the average coverage of the full transcript, averaged over all transcripts",
    )
    rna_intronic_rate: Mapped[Optional[float]] = mapped_column(
        FLOAT, comment="Intronic rate is the fraction mapping within introns"
    )
    rna_transcripts_detected: Mapped[Optional[int]] = mapped_column(
        INTEGER, comment="Number of transcripts detected with at least 5 reads"
    )
    rna_globin_percent_tpm: Mapped[Optional[float]] = mapped_column(
        FLOAT,
        comment="Percentage of globin genes TPM (transcripts per million) detected",
    )
    rna_mitochondrial_percent_tpm: Mapped[Optional[float]] = mapped_column(
        FLOAT,
        comment="Percentage of mitochondrial genes TPM (transcripts per million) detected",
    )
    gbs_call_rate: Mapped[Optional[float]] = mapped_column(
        FLOAT,
        comment="The GbS call rate is the fraction of loci called on the relevant primer panel",
    )
    gbs_pass_rate: Mapped[Optional[float]] = mapped_column(
        FLOAT,
        comment="The GbS pass rate is the fraction of loci called and passing filters on the relevant primer panel",
    )
    nrd_percent: Mapped[Optional[float]] = mapped_column(
        FLOAT(5, 2), comment="Percent of non-reference discordance"
    )
    target_filter: Mapped[Optional[str]] = mapped_column(
        VARCHAR(30), comment="Filter used to produce the target stats file"
    )
    target_length: Mapped[Optional[int]] = mapped_column(
        BIGINT, comment="The total length of the target regions"
    )
    target_mapped_reads: Mapped[Optional[int]] = mapped_column(
        BIGINT, comment="The number of mapped reads passing the target filter"
    )
    target_proper_pair_mapped_reads: Mapped[Optional[int]] = mapped_column(
        BIGINT,
        comment="The number of proper pair mapped reads passing the target filter",
    )
    target_mapped_bases: Mapped[Optional[int]] = mapped_column(
        BIGINT, comment="The number of mapped bases passing the target filter"
    )
    target_coverage_threshold: Mapped[Optional[int]] = mapped_column(
        Integer,
        comment="The coverage threshold used in the target perc target greater than depth calculation",
    )
    target_percent_gt_coverage_threshold: Mapped[Optional[float]] = mapped_column(
        FLOAT(5, 2),
        comment="The percentage of the target covered at greater than the depth specified",
    )
    target_autosome_filter: Mapped[Optional[str]] = mapped_column(
        VARCHAR(30), comment="Filter used to produce the autosome target stats file"
    )
    target_autosome_length: Mapped[Optional[int]] = mapped_column(
        BIGINT, comment="The total length of the autosomes only target regions"
    )
    target_autosome_mapped_bases: Mapped[Optional[int]] = mapped_column(
        BIGINT, comment="The number of mapped bases passing the autosome target filters"
    )
    target_autosome_coverage_threshold: Mapped[Optional[int]] = mapped_column(
        Integer,
        comment="The coverage threshold used in the perc target autosome greater than depth calculation",
    )
    target_autosome_percent_gt_coverage_threshold: Mapped[Optional[float]] = (
        mapped_column(
            FLOAT(5, 2),
            comment="The percentage of the target autosome covered at greater than the depth specified",
        )
    )
    sub_titv_class: Mapped[Optional[float]] = mapped_column(
        FLOAT, comment="The ratio of transition substitution counts to transvertion"
    )
    sub_titv_mean_ca: Mapped[Optional[float]] = mapped_column(
        FLOAT,
        comment="TiTv where count of CA+GT is taken as if it were mean across other transversions",
    )
    sub_frac_sub_hq: Mapped[Optional[float]] = mapped_column(
        FLOAT, comment="Fraction of substitutions which are high quality (>=Q30)"
    )
    sub_oxog_bias: Mapped[Optional[float]] = mapped_column(
        FLOAT,
        comment="How similar CA to GT counts are within each read (high quality >=Q30 substitutions only) in order to detect OxoG oxidative artifacts",
    )
    sub_sym_gt_ca: Mapped[Optional[float]] = mapped_column(
        FLOAT, comment="How symmetrical CA and GT counts are within each read"
    )
    sub_sym_ct_ga: Mapped[Optional[float]] = mapped_column(
        FLOAT, comment="How symmetrical CT and GA counts are within each read"
    )
    sub_sym_ag_tc: Mapped[Optional[float]] = mapped_column(
        FLOAT, comment="How symmetrical AG and TC counts are within each read"
    )
    sub_cv_ti: Mapped[Optional[float]] = mapped_column(
        FLOAT,
        comment="Coefficient of variation across all Ti substitutions = std(Ti)/mean(Ti)",
    )
    sub_gt_ti: Mapped[Optional[float]] = mapped_column(
        FLOAT,
        comment="Computed as a maximum between (i) ratio of GT counts to TC and (ii) ratio CA to GA",
    )
    sub_gt_mean_ti: Mapped[Optional[float]] = mapped_column(
        FLOAT,
        comment="Computed as a maximum between (i) ratio of GT counts to mean(Ti) and (ii) ratio CA to mean(Ti)",
    )
    sub_ctoa_oxh: Mapped[Optional[float]] = mapped_column(
        FLOAT,
        comment="This metric is used to compute the likelihood of C2A and its predicted level",
    )
    sub_ctoa_art_predicted_level: Mapped[Optional[int]] = mapped_column(
        TINYINT,
        comment="C2A predicted level - 0 = not present, 1 = low, 2 = medium and 3 = high",
    )

    iseq_flowcell: Mapped[Optional["IseqFlowcell"]] = relationship(
        "IseqFlowcell", back_populates="iseq_product_metrics"
    )
    iseq_run_lane_metrics: Mapped[Optional["IseqRunLaneMetrics"]] = relationship(
        "IseqRunLaneMetrics", back_populates="iseq_product_metrics"
    )
    iseq_product_ampliconstats: Mapped[list["IseqProductAmpliconstats"]] = relationship(
        "IseqProductAmpliconstats", back_populates="iseq_product_metrics"
    )
    iseq_product_components: Mapped[list["IseqProductComponents"]] = relationship(
        "IseqProductComponents",
        foreign_keys="[IseqProductComponents.id_iseq_pr_component_tmp]",
        back_populates="iseq_product_metrics",
    )
    iseq_product_components_: Mapped[list["IseqProductComponents"]] = relationship(
        "IseqProductComponents",
        foreign_keys="[IseqProductComponents.id_iseq_pr_tmp]",
        back_populates="iseq_product_metrics_",
    )


class PacBioProductMetrics(Base):
    __tablename__ = "pac_bio_product_metrics"
    __table_args__ = (
        ForeignKeyConstraint(
            ["id_pac_bio_rw_metrics_tmp"],
            ["pac_bio_run_well_metrics.id_pac_bio_rw_metrics_tmp"],
            ondelete="CASCADE",
            name="pac_bio_product_metrics_to_rwm_fk",
        ),
        ForeignKeyConstraint(
            ["id_pac_bio_tmp"],
            ["pac_bio_run.id_pac_bio_tmp"],
            ondelete="SET NULL",
            name="pac_bio_product_metrics_to_run_fk",
        ),
        Index(
            "pac_bio_metrics_product",
            "id_pac_bio_tmp",
            "id_pac_bio_rw_metrics_tmp",
            unique=True,
        ),
        Index("pac_bio_pr_metrics_id_product", "id_pac_bio_product", unique=True),
        Index("pac_bio_pr_metrics_to_rwm_fk", "id_pac_bio_rw_metrics_tmp"),
        Index("pb_product_qc_index", "qc"),
        {
            "comment": "A linking table for the pac_bio_run and pac_bio_run_well_metrics "
            "tables with a potential for adding per-product QC data"
        },
    )

    id_pac_bio_pr_metrics_tmp: Mapped[int] = mapped_column(Integer, primary_key=True)
    id_pac_bio_rw_metrics_tmp: Mapped[int] = mapped_column(
        Integer,
        nullable=False,
        comment='PacBio run well metrics id, see "pac_bio_run_well_metrics.id_pac_bio_rw_metrics_tmp"',
    )
    id_pac_bio_product: Mapped[str] = mapped_column(
        CHAR(64), nullable=False, comment="Product id"
    )
    id_pac_bio_tmp: Mapped[Optional[int]] = mapped_column(
        Integer, comment='PacBio run id, see "pac_bio_run.id_pac_bio_tmp"'
    )
    qc: Mapped[Optional[int]] = mapped_column(
        TINYINT(1),
        comment="The final QC outcome of the product as 0(failed), 1(passed) or NULL",
    )
    hifi_read_bases: Mapped[Optional[int]] = mapped_column(
        BIGINT, comment="The number of HiFi bases"
    )
    hifi_num_reads: Mapped[Optional[int]] = mapped_column(
        INTEGER, comment="The number of HiFi reads"
    )
    hifi_read_length_mean: Mapped[Optional[int]] = mapped_column(
        INTEGER, comment="The mean HiFi read length"
    )
    barcode4deplexing: Mapped[Optional[str]] = mapped_column(
        String(62),
        comment="The barcode recorded in producing deplexed metrics for this product",
    )
    barcode_quality_score_mean: Mapped[Optional[int]] = mapped_column(
        SMALLINT, comment="The mean barcode HiFi quality score"
    )
    hifi_bases_percent: Mapped[Optional[float]] = mapped_column(
        Float,
        comment="The HiFi bases expressed as a percentage of the total HiFi bases",
    )
    last_changed: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime,
        server_default=text("CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP"),
        comment="Date this record was created or changed",
    )

    pac_bio_run_well_metrics: Mapped["PacBioRunWellMetrics"] = relationship(
        "PacBioRunWellMetrics", back_populates="pac_bio_product_metrics"
    )
    pac_bio_run: Mapped[Optional["PacBioRun"]] = relationship(
        "PacBioRun", back_populates="pac_bio_product_metrics"
    )


class UseqProductMetrics(Base):
    __tablename__ = "useq_product_metrics"
    __table_args__ = (
        ForeignKeyConstraint(
            ["id_run"],
            ["useq_run_metrics.id_run"],
            ondelete="CASCADE",
            name="useq_pr_metrics_run_fk",
        ),
        ForeignKeyConstraint(
            ["id_useq_wafer_tmp"],
            ["useq_wafer.id_useq_wafer_tmp"],
            ondelete="SET NULL",
            name="useq_pr_metrics_wafer_fk",
        ),
        Index("useq_pm_run_tag_index", "id_run", "tag_index"),
        Index("useq_pm_seqcontrol_tag_index", "is_sequencing_control", "tag_index"),
        Index("useq_pm_tagseq_index", "ultimagen_Index_Sequence"),
        Index("useq_pr_metrics_wafer_fk", "id_useq_wafer_tmp"),
        Index("useq_prm_product_unique", "id_useq_product", unique=True),
        Index("useq_sample_name", "ultimagen_Sample_Id"),
    )

    id_useq_pr_metrics_tmp: Mapped[int] = mapped_column(
        BIGINT,
        primary_key=True,
        comment="Internal to this database id, value can change",
    )
    id_run: Mapped[int] = mapped_column(
        INTEGER, nullable=False, comment="NPG run identifier"
    )
    id_useq_product: Mapped[str] = mapped_column(
        CHAR(64, collation="utf8mb3_unicode_ci"), nullable=False, comment="Product id"
    )
    last_changed: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime,
        server_default=text("CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP"),
        comment="Date this record was created or changed",
    )
    id_useq_wafer_tmp: Mapped[Optional[int]] = mapped_column(
        INTEGER, comment='Foreign key, see "useq_wafer.id_useq_wafer_tmp"'
    )
    tag_index: Mapped[Optional[int]] = mapped_column(SMALLINT, comment="NPG tag index")
    is_sequencing_control: Mapped[Optional[int]] = mapped_column(
        TINYINT(1),
        server_default=text("'0'"),
        comment="A boolean flag. If true, this is an internal control",
    )
    ultimagen_Index_Label: Mapped[Optional[str]] = mapped_column(
        String(255, "utf8mb3_unicode_ci"), comment="Ultimagen barcode label"
    )
    ultimagen_Index_Sequence: Mapped[Optional[str]] = mapped_column(
        String(255, "utf8mb3_unicode_ci"), comment="Ultimagen barcode sequence"
    )
    ultimagen_Sample_Id: Mapped[Optional[str]] = mapped_column(
        String(255, "utf8mb3_unicode_ci"),
        comment="Sample ID used by Ultimagen Genomics in deplexing, see also ultimagen:Sample_ID iRODS metadata",
    )
    ultimagen_Library_Name: Mapped[Optional[str]] = mapped_column(
        String(255, "utf8mb3_unicode_ci"),
        comment="Library name as given in Ultimagen Genomics manifest, see also ultimagen:Library_name iRODS metadata",
    )
    qc_seq: Mapped[Optional[int]] = mapped_column(
        TINYINT(1),
        comment="Sequencing lane level QC outcome, a result of either manual or automatic assessment by core",
    )
    qc_lib: Mapped[Optional[int]] = mapped_column(
        TINYINT(1),
        comment="Library QC outcome, a result of either manual or automatic assessment by core",
    )
    qc: Mapped[Optional[int]] = mapped_column(
        TINYINT(1),
        comment="Overall QC assessment outcome, a logical product (conjunction) of qc_seq and qc_lib values, defaults to the qc_seq value when qc_lib is not defined",
    )
    tag_decode_count: Mapped[Optional[int]] = mapped_column(
        BIGINT,
        comment="Number of reads on a wafer assigned to this library after deplexing",
    )
    tag_decode_percent: Mapped[Optional[float]] = mapped_column(
        FLOAT,
        comment="Percent of reads on a wafer, which is assigned to this library after deplexing",
    )
    q20_yield_kb: Mapped[Optional[int]] = mapped_column(
        INTEGER, comment="Yield in KBs at and above Q20"
    )
    q30_yield_kb: Mapped[Optional[int]] = mapped_column(
        INTEGER, comment="Yield in KBs at and above Q30"
    )
    total_yield_kb: Mapped[Optional[int]] = mapped_column(
        INTEGER, comment="Overall sample yield in KBs"
    )

    useq_run_metrics: Mapped["UseqRunMetrics"] = relationship(
        "UseqRunMetrics", back_populates="useq_product_metrics"
    )
    useq_wafer: Mapped[Optional["UseqWafer"]] = relationship(
        "UseqWafer", back_populates="useq_product_metrics"
    )


class IseqProductAmpliconstats(Base):
    __tablename__ = "iseq_product_ampliconstats"
    __table_args__ = (
        ForeignKeyConstraint(
            ["id_iseq_product"],
            ["iseq_product_metrics.id_iseq_product"],
            name="iseq_pastats_prm_fk",
        ),
        Index(
            "iseq_hrm_digest_unq",
            "id_iseq_product",
            "primer_panel",
            "amplicon_index",
            unique=True,
        ),
        Index("iseq_pastats_amplicon", "primer_panel_num_amplicons", "amplicon_index"),
        {
            "comment": "Some of per sample per amplicon metrics generated by samtools "
            "ampliconstats"
        },
    )

    id_iseq_pr_astats_tmp: Mapped[int] = mapped_column(
        BIGINT,
        primary_key=True,
        comment="Internal to this database id, value can change",
    )
    id_iseq_product: Mapped[str] = mapped_column(
        CHAR(64),
        nullable=False,
        comment="Product id, a foreign key into iseq_product_metrics table",
    )
    primer_panel: Mapped[str] = mapped_column(
        VARCHAR(255),
        nullable=False,
        comment="A string uniquely identifying the primer panel",
    )
    primer_panel_num_amplicons: Mapped[int] = mapped_column(
        SMALLINT,
        nullable=False,
        comment="Total number of amplicons in the primer panel",
    )
    amplicon_index: Mapped[int] = mapped_column(
        SMALLINT,
        nullable=False,
        comment="Amplicon index (position) in the primer panel, from 1 to the value of primer_panel_num_amplicons",
    )
    pp_name: Mapped[str] = mapped_column(
        VARCHAR(40),
        nullable=False,
        comment="Name of the portable pipeline that generated the data",
    )
    created: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime,
        server_default=text("CURRENT_TIMESTAMP"),
        comment="Datetime this record was created",
    )
    last_changed: Mapped[Optional[datetime.datetime]] = mapped_column(
        DateTime,
        server_default=text("CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP"),
        comment="Datetime this record was created or changed",
    )
    pp_version: Mapped[Optional[str]] = mapped_column(
        VARCHAR(40),
        comment="Version of the portable pipeline and/or samtools that generated the data",
    )
    metric_FPCOV_1: Mapped[Optional[decimal.Decimal]] = mapped_column(
        DECIMAL(5, 2), comment="Coverage percent at depth 1"
    )
    metric_FPCOV_10: Mapped[Optional[decimal.Decimal]] = mapped_column(
        DECIMAL(5, 2), comment="Coverage percent at depth 10"
    )
    metric_FPCOV_20: Mapped[Optional[decimal.Decimal]] = mapped_column(
        DECIMAL(5, 2), comment="Coverage percent at depth 20"
    )
    metric_FPCOV_100: Mapped[Optional[decimal.Decimal]] = mapped_column(
        DECIMAL(5, 2), comment="Coverage percent at depth 100"
    )
    metric_FREADS: Mapped[Optional[int]] = mapped_column(
        INTEGER, comment="Number of aligned filtered reads"
    )

    iseq_product_metrics: Mapped["IseqProductMetrics"] = relationship(
        "IseqProductMetrics", back_populates="iseq_product_ampliconstats"
    )


class IseqProductComponents(Base):
    __tablename__ = "iseq_product_components"
    __table_args__ = (
        ForeignKeyConstraint(
            ["id_iseq_pr_component_tmp"],
            ["iseq_product_metrics.id_iseq_pr_metrics_tmp"],
            name="iseq_pr_comp_pr_comp_fk",
        ),
        ForeignKeyConstraint(
            ["id_iseq_pr_tmp"],
            ["iseq_product_metrics.id_iseq_pr_metrics_tmp"],
            ondelete="CASCADE",
            name="iseq_pr_comp_pr_fk",
        ),
        Index("iseq_pr_comp_compi", "component_index", "num_components"),
        Index("iseq_pr_comp_ncomp", "num_components", "id_iseq_pr_tmp"),
        Index("iseq_pr_comp_pr_comp_fk", "id_iseq_pr_component_tmp"),
        Index(
            "iseq_pr_comp_unique",
            "id_iseq_pr_tmp",
            "id_iseq_pr_component_tmp",
            unique=True,
        ),
    )

    id_iseq_pr_components_tmp: Mapped[int] = mapped_column(
        BIGINT,
        primary_key=True,
        comment="Internal to this database id, value can change",
    )
    id_iseq_pr_tmp: Mapped[int] = mapped_column(
        BIGINT,
        nullable=False,
        comment="iseq_product_metrics table row id for the product",
    )
    id_iseq_pr_component_tmp: Mapped[int] = mapped_column(
        BIGINT,
        nullable=False,
        comment="iseq_product_metrics table row id for one of this product's components",
    )
    num_components: Mapped[int] = mapped_column(
        TINYINT, nullable=False, comment="Number of component products for this product"
    )
    component_index: Mapped[int] = mapped_column(
        TINYINT,
        nullable=False,
        comment="Unique component index within all components of this product, \na value from 1 to the value of num_components column for this product",
    )

    iseq_product_metrics: Mapped["IseqProductMetrics"] = relationship(
        "IseqProductMetrics",
        foreign_keys=[id_iseq_pr_component_tmp],
        back_populates="iseq_product_components",
    )
    iseq_product_metrics_: Mapped["IseqProductMetrics"] = relationship(
        "IseqProductMetrics",
        foreign_keys=[id_iseq_pr_tmp],
        back_populates="iseq_product_components_",
    )
